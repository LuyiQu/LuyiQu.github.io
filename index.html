<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="瞿璐祎的博客" type="application/atom+xml">






<meta name="description" content="blog">
<meta name="keywords" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="瞿璐祎的博客">
<meta property="og:url" content="https://luyiqu.github.io/index.html">
<meta property="og:site_name" content="瞿璐祎的博客">
<meta property="og:description" content="blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瞿璐祎的博客">
<meta name="twitter:description" content="blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="https://luyiqu.github.io/">





  <title>瞿璐祎的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">瞿璐祎的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">try something new</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>






 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/查询优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/查询优化/" itemprop="url">查询优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:13:07Z">
                2020-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/基础与索引/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/基础与索引/" itemprop="url">基础与索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:12:50Z">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库系统实现/" itemprop="url" rel="index">
                    <span itemprop="name">数据库系统实现</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>包括数据库系统实现第一章、第二章、第三章（索引）</li>
</ul>
<h1 id="数据库管理系统成分"><a href="#数据库管理系统成分" class="headerlink" title="数据库管理系统成分"></a>数据库管理系统成分</h1><p><img src="/2020/08/05/基础与索引/image-20200724142035493.png" alt="image-20200724142035493"></p>
<ul>
<li>分为两大块主要模块：查询响应和事务处理</li>
</ul>
<h2 id="查询响应"><a href="#查询响应" class="headerlink" title="查询响应"></a>查询响应</h2><ul>
<li>先由查询编译器对查询进行分析和优化（如检查语义和语法是否正确、构建语法分析树），选择物理逻辑计划</li>
<li>得到查询计划后，传给执行引擎</li>
<li>执行引擎向资源管理器请求记录or关系的元组</li>
<li>资源管理器掌握着存放关系的数据文件、文件中的数据格式和记录大小，以及支持对于数据文件中的元素进行快速查找的索引文件。查找数据的请求被传送给缓冲区管理器</li>
<li>缓冲区管理器与磁盘交互（以磁盘块 单位）</li>
</ul>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>分为两个主要部分</li>
</ul>
<h3 id="并发控制管理器"><a href="#并发控制管理器" class="headerlink" title="并发控制管理器"></a>并发控制管理器</h3><ul>
<li>负责保证事务的原子性和孤立性</li>
</ul>
<h3 id="日志和恢复管理器"><a href="#日志和恢复管理器" class="headerlink" title="日志和恢复管理器"></a>日志和恢复管理器</h3><ul>
<li>负责事务的持久性</li>
</ul>
<h1 id="辅助存储管理"><a href="#辅助存储管理" class="headerlink" title="辅助存储管理"></a>辅助存储管理</h1><h2 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h2><p><img src="/2020/08/05/基础与索引/image-20200724143448491.png" alt="image-20200724143448491"></p>
<h2 id="组织磁盘上的数据"><a href="#组织磁盘上的数据" class="headerlink" title="组织磁盘上的数据"></a>组织磁盘上的数据</h2><ul>
<li>一般，一个磁盘块中仅存放<strong>一个关系的元素</strong></li>
</ul>
<h3 id="定长记录"><a href="#定长记录" class="headerlink" title="定长记录"></a>定长记录</h3><ul>
<li>下图假定所有字段必须以一个4的倍数的字节开始</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724150344115.png" alt="image-20200724150344115"></p>
<p><img src="/2020/08/05/基础与索引/image-20200724150409109.png" alt="image-20200724150409109"></p>
<ul>
<li>当存取或修改记录时，记录（与整个块一起）就被移进主存</li>
<li>块首部包含：<ul>
<li>与一个或多个其他块的链接</li>
<li>关于这个块在这样一个网络中所扮演的角色的信息</li>
<li>关于这个块的元组属于哪个关系的信息</li>
<li>一个给出每一条记录在块内偏移量的“目录”</li>
<li>指明块最后一次修改和/或存取时间的时间戳</li>
</ul>
</li>
<li>记录长度为316字节，假定4096字节的块，会有292字节的浪费</li>
</ul>
<h2 id="块和记录地址的表示"><a href="#块和记录地址的表示" class="headerlink" title="块和记录地址的表示"></a>块和记录地址的表示</h2><ul>
<li>内存中：与虚拟内存地址相关</li>
<li>二级存储器中：与磁盘的设备ID，柱面号等等相关</li>
</ul>
<h3 id="客户机-服务器系统中的地址"><a href="#客户机-服务器系统中的地址" class="headerlink" title="客户机-服务器系统中的地址"></a>客户机-服务器系统中的地址</h3><ul>
<li>服务器：为客户端进程提供二级存储器数据，数据处于数据库地址空间，表示地址的方法有：<ul>
<li>物理地址（字符串）：<ul>
<li>存储所连接的主机</li>
<li>块所在的磁盘或其它设备的标识符</li>
<li>柱面号</li>
<li>磁道号</li>
<li>块号</li>
<li>块内偏移量</li>
</ul>
</li>
<li>逻辑地址</li>
</ul>
</li>
<li>客户端：其地址空间看作主存本身</li>
</ul>
<h2 id="指针混写"><a href="#指针混写" class="headerlink" title="指针混写"></a>指针混写</h2><ul>
<li>把块从二级存储器移到主存储器中，块内指针可以“混写”，即从数据库地址空间转换为虚拟地址空间</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724153804351.png" alt="image-20200724153804351"></p>
<h3 id="被钉住的记录和块"><a href="#被钉住的记录和块" class="headerlink" title="被钉住的记录和块"></a>被钉住的记录和块</h3><ul>
<li>即内存中一个块当前不能安全地被写回磁盘</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724154305211.png" alt="image-20200724154305211"></p>
<h2 id="变长数据和记录"><a href="#变长数据和记录" class="headerlink" title="变长数据和记录"></a>变长数据和记录</h2><h3 id="变长字段的记录"><a href="#变长字段的记录" class="headerlink" title="变长字段的记录"></a>变长字段的记录</h3><ul>
<li>当address地址为NULL时，直接在指向的指针空间处放一个空指针，进一步减少空间。</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724154657714.png" alt="image-20200724154657714"></p>
<h3 id="具有重复字段的记录"><a href="#具有重复字段的记录" class="headerlink" title="具有重复字段的记录"></a>具有重复字段的记录</h3><ul>
<li>法一：</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155032593.png" alt="image-20200724155032593"></p>
<ul>
<li>法二：<ul>
<li>保证记录定长，有效对记录进行搜索，但增加 磁盘I/O数目</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155045741.png" alt="image-20200724155045741"></p>
<ul>
<li><h3 id="不能装入一个块中的记录"><a href="#不能装入一个块中的记录" class="headerlink" title="不能装入一个块中的记录"></a>不能装入一个块中的记录</h3></li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155711393.png" alt="image-20200724155711393"></p>
<ul>
<li>BOLB(二进制大对象)</li>
</ul>
<h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><ul>
<li>适用于：大多数查询请求是<strong>针对所有数据</strong>或者<strong>列的大部分数据</strong>。（常用于“分析型”查询）</li>
<li>可以与值一起保存元组ID号~</li>
</ul>
<h2 id="记录的修改"><a href="#记录的修改" class="headerlink" title="记录的修改"></a>记录的修改</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>元组以某个固定次序存储（如按主键顺序存储）</li>
<li>插入的两种方法：（使用偏移量加速找到插入的位置）<img src="/2020/08/05/基础与索引/image-20200724162909062.png" alt="image-20200724162909062"><ul>
<li>在“邻近块”中找空间</li>
<li>创建一个溢出块</li>
</ul>
</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p>在记录处放删除标志</p>
<ul>
<li>可以是偏移量表中的空指针</li>
<li>可以用删除标记代替记录,只用到第一个字节，后续的字节可用于另一个记录~</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724164311442.png" alt="image-20200724164311442"></p>
</li>
</ul>
<p>### </p>
<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><p><strong>主索引&amp;辅助索引</strong>：主索引（主键）能确定记录在数据文件中的位置，而辅助索引不能</p>
</li>
<li><p>索引类型：顺序文件（稠密索引、稀疏索引）、B树索引、散列表索引。</p>
</li>
<li><p>稠密索引：为数据文件中的每条记录设一个键-指针对。其中所索引快保持键的顺序与文件中的排序顺序一致。（记录时排好序的）</p>
</li>
<li><p>稀疏索引：为数据文件中的每个存储块设一个键-指针对。（假定数据文件排好序）【只会是主索引】</p>
</li>
<li><p>多级索引：索引文件占据多个存储块，可采用多级索引【主索引】</p>
</li>
<li><p>辅助索引：总是稠密索引，因为不是主键索引（如果该column也不是unique的)，那就存在多个相同的索引内容，索引数据跨越多个块。<strong>使用辅助索引比使用主索引可能需要多得多的磁盘I/O，但无法解决！</strong></p>
<ul>
<li>避免键值重复：使用桶的间接层</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200725220045067.png" alt="image-20200725220045067"></p>
<p><img src="/2020/08/05/基础与索引/image-20200726143152340.png" alt="image-20200726143152340"></p>
</li>
<li><p>辅助索引的运用：</p>
<ul>
<li><p>被组织成顺序文件的关系（如上都是）</p>
</li>
<li><p>作为“堆”结构的主键索引（不太能理解）</p>
</li>
<li><p>聚集文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Movie(title,year,length,genre,studioName,producerC<span class="comment">#)</span></span><br><span class="line">Studio(name,address,presC<span class="comment">#)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> title,<span class="keyword">year</span></span><br><span class="line"><span class="keyword">From</span> Movie,Studio</span><br><span class="line"><span class="keyword">WHERE</span> presC<span class="comment"># = zzz AND Movie.studioName = Studio.name;(假定这是该应用场景典型的查询)</span></span><br><span class="line"></span><br><span class="line">为这个两个关系建立一个聚集文件结构，在查询键presC<span class="comment">#上建立索引。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/05/基础与索引/image-20200725221051780.png" alt="image-20200725221051780"></p>
</li>
</ul>
</li>
</ul>
<h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><ul>
<li>B-树根结点块是永久地缓冲在主存中的绝佳选择。</li>
</ul>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul>
<li><p>插入时，若没有位置，就存储到该块链上的某个溢出块中。</p>
</li>
<li><p>删除时，若块中前一条记录被删除，就一条记录需移动到前面。</p>
<p><img src="/2020/08/05/基础与索引/image-20200726151506740.png" alt="image-20200726151506740"></p>
</li>
</ul>
<h3 id="可扩展散列表"><a href="#可扩展散列表" class="headerlink" title="可扩展散列表"></a>可扩展散列表</h3><ul>
<li><p>动态散列表之一</p>
</li>
<li><p>引入间接层，用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶。</p>
</li>
<li><p>指针数组能增长，长度总是2的幂。</p>
<p><img src="/2020/08/05/基础与索引/image-20200726152253294.png" alt="image-20200726152253294"></p>
</li>
<li><p>通过判断i和j（右上角小块中的）的大小，不断加倍桶数组，且分裂数据块。</p>
</li>
<li><p>优点：若桶数组小到可以存放在内存中，那么访问桶数组就不需要进行磁盘I/O。</p>
</li>
</ul>
<h3 id="线性散列表"><a href="#线性散列表" class="headerlink" title="线性散列表"></a>线性散列表</h3><p><img src="/2020/08/05/基础与索引/image-20200726153509875.png" alt="image-20200726153509875"></p>
<ul>
<li>i(当前被使用的散列函数值的位数)、n（当前的桶数）、r（当前散列表中的记录总数）</li>
<li>（没怎么看懂）</li>
<li>优点：桶的增长较为缓慢</li>
</ul>
<h2 id="多维索引"><a href="#多维索引" class="headerlink" title="多维索引"></a>多维索引</h2><ul>
<li>数据结构：类散列表方法，类树方法</li>
</ul>
<h4 id="多维数据的散列结构"><a href="#多维数据的散列结构" class="headerlink" title="多维数据的散列结构"></a>多维数据的散列结构</h4><ul>
<li>网格文件：通过排序该维的值来划分该维</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200726161359875.png" alt="image-20200726161359875"></p>
<ul>
<li><p>当数据分布性很好，且数据文件本身又不太大，那么可以选择网格线。</p>
</li>
<li><p>分段散列：为每个二进制位设定一个属性</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162116830.png" alt="image-20200726162116830" style="zoom:50%;"></p>
<ul>
<li>对最近邻查询或范围查询实际上没有什么用，因为点之间的物理距离并没有通过桶号的接近反映出来。</li>
<li>如果只需要支持部分匹配查询，只需要指定某属性的值而不指定其他属性，那么分段散列函数可能会比网格文件好。</li>
</ul>
</li>
</ul>
<h4 id="多维数据的树结构"><a href="#多维数据的树结构" class="headerlink" title="多维数据的树结构"></a>多维数据的树结构</h4><ul>
<li><p>多键索引</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162746159.png" alt="image-20200726162746159" style="zoom:50%;"></p>
</li>
<li><p>kd-树</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162909353.png" alt="image-20200726162909353" style="zoom:50%;"></p>
</li>
<li><p>四叉树：根据象限来划分</p>
<p><img src="/2020/08/05/基础与索引/image-20200726163747603.png" alt="image-20200726163747603" style="zoom:50%;"></p>
</li>
<li><p>R-树（内部结点对应于某个内部区域）</p>
<ul>
<li>对于”where-am-I”这类典型查询，R树是有用的。</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200726164316027.png" alt="image-20200726164316027" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h2><ul>
<li>每条记录作为二进制位，针对年龄这个字段，如18岁，假定有6条记录可能在第1,2,3条记录的年龄为18岁，则位图表示为111000</li>
<li>压缩位图：采用分段长度编码</li>
</ul>
<p>注： 一般做删除操作，都直接在数据文件中采用“删除标记”</p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/skywalking适配mysql/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/skywalking适配mysql/" itemprop="url">skywalking适配mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:10:23Z">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/skywalking/" itemprop="url" rel="index">
                    <span itemprop="name">skywalking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>为了去抓取应用端发来的负载信息，比如sql,timestamp,sql中的para,和select语句的result集合，通过分析这些负载，来模拟负载，主要用于抓取应用端的负载，相当于数据挖掘中获取数据的来源把~~</p>
</li>
<li><p>这篇主要是总结我在适配skywalking获取mysql应用端的负载遇到的问题和感受。</p>
</li>
</ul>
<h1 id="先行"><a href="#先行" class="headerlink" title="先行"></a>先行</h1><ul>
<li><p>利用skywalking在以mysql为数据库的应用程序中抓取负载，在实验中，以oltpbench为应用端。大致的配置是，在<a href="https://github.com/apache/skywalking拉去skywalking源代码，利用说明文档进行编译" target="_blank" rel="noopener">https://github.com/apache/skywalking拉去skywalking源代码，利用说明文档进行编译</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/skywalking.git</span><br><span class="line">cd skywalking/</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">./mvnw clean package -DskipTests</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译好的在dist目录下，如果没有别的需求，可直接在启动应用端的脚本或命令行中加入-javaagent /skywalking/agent/skywalking-agent.jar。</p>
</li>
<li>由于项目中需要按照一定的形式将抓取到的日志输入固定的文件中，因此主要对skywalking的三个包进行修改，分别是mysql-common,mysql-5.x,jdbc-commons，这三个都在./apm-sniffer/apm-sdk-plugins中。</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="mysql-commons"><a href="#mysql-commons" class="headerlink" title="mysql-commons"></a>mysql-commons</h2><ul>
<li>里面都是一些截流器，有针对预编译sql的PreparadStatementExeucute，还有PreparadStatementBatchExeucute，和普通的StateExecute。这些截流器都被注册了，与mysql-5.x中的注册器对应，注册器指明mysql中哪里函数利用那些截流器去捕获。如”add batch”函数就利用PreparadStatementBatchExeucute去抓取。”executeUpdate”利用PreparadStatementExeucute和StateExecute去抓取（根据不同的sql类型）</li>
</ul>
<h2 id="mysql-5-x"><a href="#mysql-5-x" class="headerlink" title="mysql-5.x"></a>mysql-5.x</h2><ul>
<li>一些注册器，与拦截器对应即可</li>
</ul>
<h2 id="jdbc-commons"><a href="#jdbc-commons" class="headerlink" title="jdbc-commons"></a>jdbc-commons</h2><ul>
<li>主要是加了connId，还有与commit,rollback有关的拦截器，在这个包中，也进行了修改。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="mysql-的-jdbc重复调用问题"><a href="#mysql-的-jdbc重复调用问题" class="headerlink" title="mysql 的 jdbc重复调用问题"></a>mysql 的 jdbc重复调用问题</h2><ul>
<li><p>查看Mysql的jdbc的包（可利用反编译软件进行查看），发现add batch又调用了executeUpdate函数，导致skywalking抓包的时候重复捕获一条语句，导致重复。此外，还有executeUpdate自调用三次，导致一条日志被打印出三次。这类问题的处理方式，利用查看调用栈，分析它的调用过程，来忽略一些日志的输出。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception ex = <span class="keyword">new</span> Exception();</span><br><span class="line">StackTraceElement[] ste = ex.getStackTrace();</span><br><span class="line"><span class="keyword">boolean</span> fromExecuteBatch = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ste.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ste[i].getMethodName().contains(<span class="string">"executeBatch"</span>)||ste[i].getMethodName().contains(<span class="string">"executeUpdate$Original"</span>))&#123;</span><br><span class="line">        fromExecuteBatch = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mysql中以一个host为一个connId"><a href="#mysql中以一个host为一个connId" class="headerlink" title="mysql中以一个host为一个connId"></a>mysql中以一个host为一个connId</h2><ul>
<li>由于项目的需要，我们需要得到connId，在jdbc-commons的相应位置加上与connId相关的代码。</li>
<li>但是发现createstatement有个问题，就是无论多少个线程，以及无论多少个连接，但输出总是一个相同的。但从mysql端捕获到的connectionInfo都是不同的，后来发现是skywalking中是根据host和Port来存储connectionInfo的，若从相同的host和port发送数据库请求，那skywalking（mysql部分，oracle应该不是这样的)就认为是用一条connectionInfo信息，导致出错。</li>
<li>这个问题的解决方法：就不用host和port进行存储..换了另一种方式。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>skywalking适配mysql耗时达1周左右，发现自己还是畏惧源码的阅读，无论是skywalking还是mysql-jdbc还是不能有效的进行阅读，希望下次能改进。</li>
<li>自己对于问题的解决不能深入，抱着懒散的心态~，要加油呀！</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/" itemprop="url">SQLCheck: Automated Detection and Diagnosis of SQL Anti-Patterns</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:50:50Z">
                2020-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>数据库即服务（DBaaS)目前很流行，云计算的出现，让很多开发人员都直接使用云上数据库而不用自己去搭建一个数据库，这扩展了数据库的使用，但很多开发人员没有数据库相关知识，可能写出来的sql语句存在APs（Anti-Patterns)，而APs会影响访问数据库时的性能，进而对应用产生影响。因此，这篇文章站在这个角度，去检测sql语句是否存在APs，并且将sql中存在的APs进行排序（这里主要是为了修复主要影响性能的APs，因为修复APs可能修改数据库schema等等，会对其他的sql产生一定影响），最后对主要的APs进行自动修复（实质上这篇文章是按照现有的规则进行修复）。</li>
</ul>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><ul>
<li>AP可能违反基本数据库设计原则（如，参照一致性等等）</li>
</ul>
<h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><ul>
<li><p>讲述了如今其他识别APs的工具的局限性</p>
</li>
<li><p>注意：detection是有按照一定的rule进行匹配来将AP侦测出来</p>
</li>
<li><p>Detection：将query和data分析相结合进行AP侦测。</p>
</li>
<li><p>Rank：针对APs上的<strong>性能数据进行建模</strong>，获取rank model。</p>
</li>
<li><p>Fix：基于规则query重构技术提出fix APs的建议。</p>
</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Classification-of-Anti-Patterns"><a href="#Classification-of-Anti-Patterns" class="headerlink" title="Classification of Anti-Patterns"></a><strong>Classification of Anti-Patterns</strong></h2><p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717144713076.png" alt="image-20200717144713076"></p>
<h2 id="Impact-of-Anti-Patterns"><a href="#Impact-of-Anti-Patterns" class="headerlink" title="Impact of Anti-Patterns"></a><strong>Impact of Anti-Patterns</strong></h2><ul>
<li><strong>Performance</strong>：性能，如吞吐和延迟</li>
<li><strong>Maintainability:</strong>当业务发生了改变，应用设计和组件被修改的容易程度（这里指sql和schema）</li>
<li><strong>Accuracy:</strong>存进去的数据和读出来的时候是否还是一致的（如，浮点数的精度是否丢失了，考虑数据库schema的column类型定义的如何）</li>
</ul>
<h1 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h1><p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717175237267.png" alt="image-20200717175237267"></p>
<ul>
<li>ap-detect:静态分析queries，分析数据库中的数据和元数据</li>
<li>ap-rank：根据detect出来的AP对各类评价指标的影响排序（文中设置user-study,由于可以根据自己的应用需求调整不同评价指标的权重，如读事务多的应用场景对读性能更为看重）</li>
<li>ap-fix：根据定义好的rule来对AP进行fix（也就是说rule是有限的，无法cover到全部，<strong>这里detect从后面的实验来看也应该是有限的AP，就是定义的AP越多识别出来的也越多…</strong>）</li>
</ul>
<h1 id="Finding-Anti-Patterns"><a href="#Finding-Anti-Patterns" class="headerlink" title="Finding Anti-Patterns"></a>Finding Anti-Patterns</h1><ul>
<li>Query-Analyser：获取query的column name、table names、predicates、constraints和indexes等等（就是一些logical feature)</li>
<li>Data-Analyser：获取数据库中表的每个Column的数据分布和format（类型？）等</li>
<li>Query-Rules：根据建立好的rules识别APs判别query是否存在APs</li>
<li>Data-Rules：根据建立好的rules识别APs判别data是否存在APs</li>
</ul>
<p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717180220192.png" alt="image-20200717180220192"></p>
<h2 id="Query-Analysis"><a href="#Query-Analysis" class="headerlink" title="Query Analysis"></a><strong>Query Analysis</strong></h2><ul>
<li><strong>intra-query detection：</strong>从单条sql获取context，使用预定好的rule（rule里由一系列函数组成）去detect，使用<strong>no-validating parsing logic</strong>来支持不同数据库的查询，返回<strong>annotating the parse tree</strong>(ap-detect和ap-fix使用这个去找到APS)</li>
<li>inter-query detection：从sql和sql之间获取context，利用整个应用的context，不一定是相邻的,在 Intra-query上多包涵了两个组件：<strong>schama和与应用相关的queries</strong></li>
</ul>
<h2 id="Data-Analysis"><a href="#Data-Analysis" class="headerlink" title="Data Analysis"></a>Data Analysis</h2><ul>
<li>首先scan<strong>数据库</strong>收集【收集代价大，定期执行】：<ul>
<li>tables的schemata</li>
<li>数据在相关column上的分布（<em>e.g.</em>, unique values,mean, median等等）</li>
</ul>
</li>
<li>还是根据相应的规则去check构建好的context中是否存在APs</li>
</ul>
<h1 id="Ranking-Anti-Patterns"><a href="#Ranking-Anti-Patterns" class="headerlink" title="Ranking Anti-Patterns"></a>Ranking Anti-Patterns</h1><h2 id="Metrics-for-Ranking-Anti-Patterns"><a href="#Metrics-for-Ranking-Anti-Patterns" class="headerlink" title="Metrics for Ranking Anti-Patterns"></a>Metrics for Ranking Anti-Patterns</h2><ul>
<li><strong>Read and Write Performance (RP, WP)：</strong>读写性能。通过如果修复好这个AP能获取多少倍的加速。这个指标作为rank依据。</li>
<li><strong>Maintainability (M)</strong>：可维护性 是根据支持新的task时，数据库 在存在这个AP和不存在这个AP需要重构时改变的Number的差异,当number高度依赖于应用中的queries数时，这个AP优先级就会很高。</li>
<li><strong>Data Amplification (DA)</strong>：冗余的列，如age和出生年月；各种冗余不必要的信息。</li>
<li><strong>Data Integrity (DI):</strong> 更新是否保证数据库中保存的是想要的数据</li>
<li><strong>Accuracy (A):</strong> 如是否满足参照一致性</li>
</ul>
<h2 id="Model-for-Ranking-Anti-Patterns"><a href="#Model-for-Ranking-Anti-Patterns" class="headerlink" title="Model for Ranking Anti-Patterns"></a>Model for Ranking Anti-Patterns</h2><ul>
<li>运用开发人员根据自己的开发需求去设置上方metrics的权重。（实际上开发人员也很难去做到这个，这里可以做一个权重自动化设置工具）</li>
<li>当APs之间发生冲突时，即修复一个AP会影响恶化另外一个AP，那就选择优先级高的AP进行修复</li>
</ul>
<h1 id="Fixing-Anti-Patterns"><a href="#Fixing-Anti-Patterns" class="headerlink" title="Fixing Anti-Patterns"></a>Fixing Anti-Patterns</h1><ul>
<li>自动推荐合适应用场景的数据库设计和queries。</li>
</ul>
<p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200720130345206.png" alt="image-20200720130345206"></p>
<ul>
<li>两部分的query需要transform: 1. 具有APs的部分 2. 修改APsquery会影响的部分query</li>
<li>如果产生模糊的转换，那就返回一个textual fix，就是说这个工具不足够帮你fix…那它告诉你啥textual fix呢，让开发人员自己看着做</li>
<li>绿色部分解析： 如果query transformation清晰，那就把它解析成语法树，之后转换成sql语句。（数据库的语法树解析感觉有时间可以看看）</li>
</ul>
<h2 id="Query-Repair-Engine"><a href="#Query-Repair-Engine" class="headerlink" title="Query Repair Engine"></a>Query Repair Engine</h2><ul>
<li>rule system是可扩展的，开发人员可以自己把rule按照一定的要求加进去。</li>
<li>首先，规则系统范式使得ap-fix很容易利用修复规则之间复杂的触发交互，从而避免了显式布局流的需要 规则之间的控制（这里没看懂，就直接有道翻译了一下）</li>
</ul>
<h3 id="Rule-Representation"><a href="#Rule-Representation" class="headerlink" title="Rule Representation:"></a>Rule Representation:</h3><ul>
<li>每条规则都包含一个detection function和一个action function</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><ul>
<li><p>提供了三个接口：</p>
<ul>
<li><p>Interactive Shell:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the anti-pattern finder method</span></span><br><span class="line"><span class="keyword">from</span> sqlcheck.finder <span class="keyword">import</span> find_anti_patterns</span><br><span class="line">query = `INSERT INTO Users VALUES (<span class="number">1</span>, <span class="string">'foo'</span>)`</span><br><span class="line">results = find_anti_patterns(query)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>REST Interface</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP POST /api/check</span><br><span class="line"><span class="attribute">Body</span>: &#123;"query":"INSERT INTO Users VALUES (1,'foo')"&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>GUI Interface</li>
</ul>
<ul>
<li><p>扩展性</p>
<ul>
<li>通用的规则接口（name, type, detection rule, ranking metrics, and repair rule）</li>
<li>context builder：增加应用的context来支持复杂rules</li>
<li>用DBMS-specific解析器代替no-validating解析器</li>
</ul>
</li>
</ul>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><ul>
<li><p>与DBDEO进行比较（Digital Equipment Corporation. 1992. SQL-92 Standard.</p>
<p><a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt.）" target="_blank" rel="noopener">https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt.）</a></p>
</li>
</ul>
<h2 id="Detection-of-Anti-Patterns"><a href="#Detection-of-Anti-Patterns" class="headerlink" title="Detection of Anti-Patterns"></a>Detection of Anti-Patterns</h2><ul>
<li>AP-coverage</li>
<li>accuary</li>
<li>Dialect-Coverage：可以适用哪些DBMS</li>
</ul>
<h2 id="Ranking-and-Repair-of-Antipatterns"><a href="#Ranking-and-Repair-of-Antipatterns" class="headerlink" title="Ranking and Repair of Antipatterns"></a>Ranking and Repair of Antipatterns</h2><ul>
<li>针对几个类型的AP进行讨论<ul>
<li>索引过度使用</li>
<li>索引使用不足</li>
<li>不存在外键</li>
<li>枚举类型（只有那几个数值）</li>
</ul>
</li>
</ul>
<h2 id="User-Study"><a href="#User-Study" class="headerlink" title="User Study"></a><strong>User Study</strong></h2><ul>
<li>招募23个学生去<ul>
<li>construst SQL queries</li>
</ul>
</li>
<li>使用GUI 界面追踪这些信息：<ul>
<li>the original SQL queries</li>
<li>the fixes suggested by sqlcheck for the APs detected in the original queries</li>
<li>the re-formulated SQL queries developed by the user that incorporate these fixes.</li>
</ul>
</li>
<li>Web Applications &amp; Databases<ul>
<li>收集github上的sql query，检测人家的应用的query是否存在APs，若存在就在别人的issues中提建议或是给别人发邮件，看看 别人的回馈意见。</li>
</ul>
</li>
<li>Limitations And Future Work<ul>
<li>都是根据定好的rules来发现APs的，对于新的不在规则中的APs不能后发现</li>
</ul>
</li>
</ul>
<h1 id="TOREAD"><a href="#TOREAD" class="headerlink" title="TOREAD"></a>TOREAD</h1><ul>
<li>Tushar Sharma, Marios Fragkoulis, Stamatia Rizou, Magiel Bruntink,and Diomidis Spinellis. 2018. Smelly relations: measuring and understanding database schema quality. In <em>Proc. of ICSE</em>. ACM, 55–64.</li>
<li>[21] Cunningham &amp; Cunningham Inc. 2014. C2 Wiki. <a href="http://wiki.c2.com/?AntiPatternsCatalog" target="_blank" rel="noopener">http://wiki.c2.com/?AntiPatternsCatalog</a></li>
</ul>
<h1 id="对负载生成的启发点"><a href="#对负载生成的启发点" class="headerlink" title="对负载生成的启发点"></a>对负载生成的启发点</h1><ul>
<li>分析数据特征的时候，获取data在相关列上的分布情况，如Unique values,mean,median等（这里lauca貌似没有使用这些特征）</li>
</ul>
<h1 id="研究的主要方向"><a href="#研究的主要方向" class="headerlink" title="研究的主要方向"></a>研究的主要方向</h1><ul>
<li>与SQL Anti-pattern有关，找到、排序（该APs对性能产生影响的大小）、修复APs</li>
</ul>
<h1 id="各项性能指标"><a href="#各项性能指标" class="headerlink" title="各项性能指标"></a>各项性能指标</h1><ul>
<li><strong>Read and Write Performance (RP, WP)</strong></li>
<li><strong>Maintainability (M)</strong></li>
<li><strong>Data Amplification (DA)</strong></li>
<li><strong>Data Integrity (DI)</strong> </li>
<li><strong>Accuracy (A)</strong> </li>
</ul>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="数据库即服务"><a href="#数据库即服务" class="headerlink" title="数据库即服务"></a>数据库即服务</h2><ul>
<li>DBaaS是一种云计算服务模型，用户只需要访问数据库即可，无需设置物理硬件，安装软件或配置性能。</li>
<li>Schemate即schema的复数形式，包括table、column、data type、view、stored procedures、relationships、primary key、foreign key等</li>
</ul>
<h2 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a>Adjacency List</h2><ul>
<li><p>具有层次结构的数据</p>
</li>
<li><p>解决方法：邻接表、路径枚举(Path Enumeration)、嵌套集(Nested Sets)、闭包表(Closure Table)</p>
<ul>
<li>邻接表：在树中检索指定节点的祖先节点是很昂贵的</li>
<li>路径枚举：将祖先存储成字符串(以路径的形式)，缺点：数据库不能强制规定路径是正确形成的，或者路径中的值对应于存在的节点。维护路径字符串取决于应用程序代码，并验证它的开销是非常昂贵的。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222612709-755258849.png" alt="img"></p>
<ul>
<li><p>嵌套集：根据深度优先额外维护nsleft和nsright，便于寻找节点的所有祖先节点和所有的孩子结点，但插入和移动节点很复杂，需要重复编号nsleft和nsright，当树的使用设计频繁的插入，嵌套集不是最佳选择。</p>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222742363-381067227.png" alt="img"></p>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222746488-1903425778.png" alt="img"></p>
<ul>
<li>闭包表：多增加一个表结构，专门用来存所有的祖孙信息，不只是父子信息，更便于查询。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222757572-1586364911.png" alt="img"></p>
</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/16/MYSQL-必知必会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/MYSQL-必知必会/" itemprop="url">MYSQL 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T16:23:07Z">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础书本/" itemprop="url" rel="index">
                    <span itemprop="name">基础书本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="使用MySQL基本指令"><a href="#使用MySQL基本指令" class="headerlink" title="使用MySQL基本指令"></a>使用MySQL基本指令</h2><ul>
<li>use database1; 切换数据库</li>
<li>SHOW DATABASES; 显示所有数据库</li>
<li>SHOW TABLES;</li>
<li>SHOW COLUMNS FROM customers ;  ===  DESCRIBE CUSTOMERS;</li>
</ul>
<h2 id="limit关键字："><a href="#limit关键字：" class="headerlink" title="limit关键字："></a>limit关键字：</h2><ul>
<li>Limit 3,4 ==LIMIT 4 OFFSET 3; 从行3开始，返回4行；检索出来的第一行是行0</li>
</ul>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><ul>
<li>通常ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定，用<strong>非检索的列排序</strong>数据是完全合法的。</li>
<li>默认是升序</li>
<li>对于文本性的数据进行排序时，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为。</li>
</ul>
<h2 id="使用IN操作的优点"><a href="#使用IN操作的优点" class="headerlink" title="使用IN操作的优点"></a>使用IN操作的优点</h2><ul>
<li>语法更清楚且直观</li>
<li>一般比OR操作符清单执行更快</li>
<li>最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li>
</ul>
<h2 id="MySQL中NOT"><a href="#MySQL中NOT" class="headerlink" title="MySQL中NOT"></a>MySQL中NOT</h2><ul>
<li>支持对<strong>IN、BETWEEN和EXISTS</strong>子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</li>
</ul>
<h2 id="SQL中的谓词"><a href="#SQL中的谓词" class="headerlink" title="SQL中的谓词"></a>SQL中的谓词</h2><ul>
<li><p>谓词与函数的区别：对于通常的函数来说，返回值有可能是数字、字符串或者日期等，但是谓词的返回值都是真值（true/false/unknown）。</p>
</li>
<li><p><strong>LIKE、BETWEEN、IS NULL、IS NOT NULL、IN、EXISTS</strong></p>
<ul>
<li><p>LIKE——字符串的部分一致查询（模糊查询）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①前方一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'aaa%'</span>;</span><br><span class="line"></span><br><span class="line">②中间一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%aaa%'</span>;</span><br><span class="line">    </span><br><span class="line">③后方一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%aaa'</span>;</span><br><span class="line"></span><br><span class="line">%可以匹配0个字符。</span><br></pre></td></tr></table></figure>
</li>
<li><p>BETWEEN（and）——范围查询</p>
</li>
</ul>
</li>
</ul>
<h2 id="用通配符的技巧"><a href="#用通配符的技巧" class="headerlink" title="用通配符的技巧"></a>用通配符的技巧</h2><ul>
<li>不要过度使用通配符，注意通配符的位置。</li>
</ul>
<h1 id="MySQL的正则表达式"><a href="#MySQL的正则表达式" class="headerlink" title="MySQL的正则表达式"></a>MySQL的正则表达式</h1><ul>
<li><p>REGEXP和LIKE的区别：LIKE匹配整个串而REGEXP匹配子串</p>
</li>
<li><p>不区分大小写，为区分大小写，可使用BINARY关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE prod_name REGEXP BINARY 'JetPack .000'</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行OR匹配  ‘|’</p>
</li>
<li><p>匹配几个字符之一 [123] 表示匹配1或2或3，与1|2|3不同，前者是[1|2|3]的缩写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">From</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[123] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配范围 [1-3]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name REGEXP &apos;[1-3] Ton&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配特殊字符，如 <strong>. [] | ()</strong> ，用\\为前导，如\\.表示查找. \\也用来引用元字符</p>
</li>
<li><p>匹配字符类</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618114655099.png" alt="image-20200618114655099"></p>
</li>
</ul>
<h2 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h2><ul>
<li><p>对匹配的数目进行更强的控制</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618114850214.png" alt="image-20200618114850214"></p>
<h2 id="匹配定位符"><a href="#匹配定位符" class="headerlink" title="匹配定位符"></a>匹配定位符</h2></li>
<li><p>为了匹配特定位置的文本</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618115227926.png" alt="image-20200618115227926"></p>
<ul>
<li><p>^的双重用途：</p>
<ul>
<li><p>在集合中[]，用它来否限定该集合</p>
</li>
<li><p>用来指串的开始处</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><h2 id="拼接："><a href="#拼接：" class="headerlink" title="拼接："></a>拼接：</h2><ul>
<li><p>多数DBMS使用<strong>+</strong>或者<strong>||</strong>来实现拼接，MySQL则使用<strong>Concat()</strong>函数来实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Concat</span>(vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>)</span><br><span class="line"><span class="keyword">From</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line">Return: ACME(USA)</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTrim()函数： 删除数据右侧多余的空格。如RTrim(vend_name)</p>
</li>
<li><p>LTrim()函数：去掉串左边的空格</p>
</li>
<li><p>Trim()函数：去掉串左右两边的空格</p>
</li>
<li><p>取列的别名</p>
</li>
</ul>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><ul>
<li>以下的函数都是大多数SQL实现支持的。</li>
</ul>
<h2 id="文本处理函数："><a href="#文本处理函数：" class="headerlink" title="文本处理函数："></a>文本处理函数：</h2><ul>
<li>其中SOUNDEX()考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</li>
</ul>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620111648327.png" alt="image-20200620111648327"></p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620111657883.png" alt="image-20200620111657883"></p>
<h2 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h2><ul>
<li>MySQL使用的日期格式，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。</li>
</ul>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112323444.png" alt="image-20200620112323444"></p>
<h2 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h2><ul>
<li><p>在主要DBMS的函数中，数值函数是最一致最统一的函数</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112642455.png" alt="image-20200620112642455"></p>
</li>
</ul>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112834932.png" alt="image-20200620112834932"></p>
<ul>
<li>Distinct关键字：后面必须使用列名。</li>
</ul>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><ul>
<li><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHERE过滤行，HAVING过滤分组</p>
</li>
</ul>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><ul>
<li><p>笛卡尔积：由没有联结条件的表关系返回的结果</p>
</li>
<li><p>内部联结，也称为等值联结</p>
<ul>
<li><p>ANSI SQL规范首选<strong>INNER JOIN</strong>语法，而不是=</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h1><ul>
<li>没有主键，更新或删除表中的特定行很困难，因为没有安全的方法保证只涉及相关的行。</li>
<li>MySQL在执行匹配时默认不区分大小写。根据MySQL的配置方式，搜索可以是区分大小写的。</li>
<li>可移植的：能运行在多个系统上的代码</li>
<li>可伸缩性：能够适应不断增加的工作量而不失败。</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/16/Head-First-Java/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/Head-First-Java/" itemprop="url">Head First Java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T16:17:54Z">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础书本/" itemprop="url" rel="index">
                    <span itemprop="name">基础书本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><ul>
<li>两种变量：<ul>
<li>primitive主数据类型</li>
<li>引用变量（其值位于堆上）【相当于遥控器】</li>
</ul>
</li>
<li>对象：状态（实例变量 instance varible)、行为(方法 method)</li>
<li>主要在类中使用封装 (set 函数) 来隐藏数据<ul>
<li>将实例变量标记为private, 将get/set方法标记为public</li>
</ul>
</li>
<li>实例变量永远都会有默认值，但局部变量未被初始化 使用时被给出error，即其没有默认值<ul>
<li>integers  0</li>
<li>floating 0.0</li>
<li>boolean  false</li>
<li>reference  null</li>
</ul>
</li>
<li>变量的比较：<ul>
<li>使用==比较两个primitive 主数据类型，或者判断两个号|用是否引用同一个对象。</li>
<li>使用 equals()来判断两个对象是否在意义上相等。（像是两个 String对像是否带有相同的字节组合）</li>
</ul>
</li>
</ul>
<h1 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h1><h2 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h2><ul>
<li>对象在堆上，类中的实例变量（实质上是对象的一部分）自然也在堆上</li>
<li>局部变量和方法调用在栈上，对象引用变量与primitive主数据类型变量都是放在栈上</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>当类中手动写了一个带有参数的构造函数时，编译器不会主动帮你写一个无参数的构造函数，因此需要自己写！！</li>
<li>使用this()从某个构造函数调用同一个类的另外一个构造函数。this()只能用在构造函数中，且必须是第一行语句。super()与this()不能兼得。</li>
</ul>
<ul>
<li>、</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/14/The-ArtScience-and-Engineering-of-Fuzzing-A-Survey-/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/14/The-ArtScience-and-Engineering-of-Fuzzing-A-Survey-/" itemprop="url">The ArtScience and Engineering of Fuzzing: A Survey</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-13T22:45:48Z">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Test-Case-Geneation/" itemprop="url" rel="index">
                    <span itemprop="name">Test Case Geneation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>20200713 15:01 结  </p>
<ul>
<li>关键词：自动化软件测试，模糊化，软件安全</li>
<li>目的：作为一个survey，围绕模糊化，给它<strong>下定义</strong>，总结对软件测试提出的模糊化方面的改进，发掘有哪些创新点</li>
<li>领域： 软件测试，模糊化</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>模糊化是什么？<ul>
<li>使用生成的输入（输入存在语义和语法错误）重复运行一个项目。</li>
</ul>
</li>
<li>目前模糊化有哪些问题？<ul>
<li>一些fuzzer工具的源代码和手册实际达不到描述的那样</li>
<li>不同fuzzer工具使用的术语各大相同</li>
</ul>
</li>
<li>Fuzzing定义<ul>
<li>从fuzz输入空间生成样例测试Program，并突出<strong>PUT(Program Under Test)</strong>期望的输入空间</li>
</ul>
</li>
<li>Fuzz Testing定义<ul>
<li>使用fuzzing技术去测试看是否PUT违背安全政策</li>
<li>目的：找出program中影响安全的bugs</li>
</ul>
</li>
<li>Fuzzer定义<ul>
<li>在一个PUT上执行fuzzing testing的Program</li>
</ul>
</li>
<li>Fuzz Campaign<ul>
<li>针对一条特定安全政策，一个fuzzer在PUT上的一个特定的执行，相当于专门针对哪个安全，制作出一些sample去用fuzzer执行。</li>
</ul>
</li>
<li>Bug Oracle<ul>
<li>作为fuzzer的一部分Program，检测给定的PUT执行是否违反特定安全政策</li>
</ul>
</li>
<li>Fuzz Configuration<ul>
<li>Fuzz算法的参数配置，依赖于特定的fuzz algorithm</li>
<li></li>
</ul>
</li>
<li>设计测试工具的时候，一定先熟悉源代码和PUT的相关知识！！！</li>
</ul>
<h2 id="Fuzz-Testing-算法"><a href="#Fuzz-Testing-算法" class="headerlink" title="Fuzz Testing 算法"></a>Fuzz Testing 算法</h2><ul>
<li>有两个部分：对配置进行预处理；迭代（包括Schedule,InputGen,InputEval,ConfUpdate,Continue）<ul>
<li>PREPROCESS：执行大量操作，比如插入一些功能性代码到PUTs中，或是检测种子文件（产生测试样例）的执行速度</li>
<li>第二部分的迭代的流程：先选择一个fuzz配置；根据配置中的参数生成测试样例；用测试样例和oracle bug检测是否违背安全政策（这个应该可以自己规定），这时可以得到execinfos，这大概是为了变动配置，为了之后能选取到更具有代表性的配置去生成测试样例；根据execinfos,改变fuzz配置；最后判断fuzz配置是否进行下一轮的迭代。</li>
</ul>
</li>
</ul>
<h2 id="Fuzzer的分类"><a href="#Fuzzer的分类" class="headerlink" title="Fuzzer的分类"></a>Fuzzer的分类</h2><ul>
<li><p>根据在每次fuzz run的时候fuzzer观察到的东西多少，以下只是安全专家的一致认同，在实际使用的时候，三者的区别不太明显。</p>
</li>
<li><p>黑盒fuzzer</p>
<ul>
<li>只能看到PUT输入和输出的表现，有一些还考虑输入的结构信息</li>
</ul>
</li>
<li>白盒fuzzer<ul>
<li>可以观察到PUT的内部信息以及执行过程中的收集到的信息</li>
</ul>
</li>
<li>灰盒fuzzer<ul>
<li>可以观察到一部分PUT的内部信息和它的执行，但是不能得到PUT完成的语义，且只能对PUT执行轻量级的分析和对执行收集动态信息。即收集一些近似信息</li>
</ul>
</li>
</ul>
<h1 id="PREPROCESS"><a href="#PREPROCESS" class="headerlink" title="PREPROCESS"></a>PREPROCESS</h1><ul>
<li>预处理包括对PUT做一些性能监控（灰盒、白盒都能去PUT中获取一些反馈信息）[对PUT进行插桩]，去除冗余的配置（像种子选择），修剪种子，生成驱动应用。</li>
</ul>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><ul>
<li>白盒、灰盒中用来收集最有价值反馈的一种方法，代码插桩（在被测程序中插入完成相应工作的代码，即代码插桩技术，来获取程序中可执行语句被执行（即被覆盖）的情况）</li>
<li>分为static instrumentation和dynamic instrumentation，前者一般在源代码的编译阶段执行，后者一般在运行阶段执行。</li>
</ul>
<h3 id="Execution-Feedback"><a href="#Execution-Feedback" class="headerlink" title="Execution Feedback"></a>Execution Feedback</h3><ul>
<li>灰盒fuzzers将执行反馈作为输入去优化测试样例，AFL等文章计算分支覆盖率作为反馈内容，但容易发生分支冲突，对此CollAFL提出相应解决方法。</li>
</ul>
<h3 id="In-Memory-Fuzzing"><a href="#In-Memory-Fuzzing" class="headerlink" title="In-Memory Fuzzing"></a>In-Memory Fuzzing</h3><ul>
<li>为了最小化执行开销，每次fuzz迭代只fuzz一部分的PUT,program会保留PUT的快照，下次fuzz新的测试样例时需要恢复memory快照。这种快照可以避免执行不必要的启动代码。</li>
<li>in-memiry API fuzzing通过一个函数而不是每次迭代恢复PUT的状态，这种方式尽管有效，但是找到的bugs却不完整，因为可能调用不到这种函数（我猜是函数名生成有问题？？）</li>
</ul>
<h3 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a>Thread Scheduling</h3><ul>
<li>随机调度线程对找到race condition bugs很有效。</li>
</ul>
<h2 id="Seed-Selection"><a href="#Seed-Selection" class="headerlink" title="Seed Selection"></a>Seed Selection</h2><ul>
<li>希望选取最小的种子集合最大化覆盖率（如节点覆盖率）</li>
<li>覆盖率评价指标：<ul>
<li>branch coverage（计算分支的执行次数），当测试样例在分支执行次数上的数量级不同时才认为它们是不同的</li>
<li>the number of executed instructions,executed branches,and unique basic block。希望将最长的执行路径的测试样例增加到minset中。</li>
</ul>
</li>
</ul>
<h2 id="Seed-Trimming"><a href="#Seed-Trimming" class="headerlink" title="Seed Trimming"></a>Seed Trimming</h2><ul>
<li><p>在preprocess中执行，或作为CONFUPDATE的一部分</p>
</li>
<li><p>在AFL中只要修改过的seed能够达到和原先种子一样的覆盖率，就修剪掉原先种子。</p>
</li>
<li>[177]发现size小的种子没啥用</li>
</ul>
<h2 id="Preparing-a-Driver-Application"><a href="#Preparing-a-Driver-Application" class="headerlink" title="Preparing a Driver Application"></a>Preparing a Driver Application</h2><ul>
<li>给fuzzer一开始的时候准备一个驱动器（这里不太理解）</li>
</ul>
<h1 id="SCHEDULING"><a href="#SCHEDULING" class="headerlink" title="SCHEDULING"></a>SCHEDULING</h1><ul>
<li>选择一个fuzz 配置为下轮fuzz迭代，不同的fuzzer类型具有不同的配置。这里主要的研究点是提出创新性的scheduling算法。</li>
</ul>
<h2 id="The-Fuzz-Cofiguration-Scheduling-FCS-Problem"><a href="#The-Fuzz-Cofiguration-Scheduling-FCS-Problem" class="headerlink" title="The Fuzz Cofiguration Scheduling (FCS) Problem"></a>The Fuzz Cofiguration Scheduling (FCS) Problem</h2><ul>
<li>挑选一个可能产生最好结果的配置（评判可能依据 find the most number of unique bugs[unique bugs不知道咋翻译], maximize the coverage]。在挑选的时候考虑explore（关于每个配置获取更为准确的信息）和exploit（获取好的结果），做这两者的trade-off。</li>
</ul>
<h2 id="Black-box-FCS-Algorithms"><a href="#Black-box-FCS-Algorithms" class="headerlink" title="Black-box FCS Algorithms"></a>Black-box FCS Algorithms</h2><ul>
<li>黑盒用到的反馈信息：crashes和bug的数量毕竟执行时间</li>
<li>[225]提炼数学模型，WCCP/UW，由于反馈信息会随着配置结果变差，因此选择一些配置不会导致反馈decay。为了将crashes或bugs / time来修改反馈信息，目的是为了能更快速地进行配置（感觉是把time因素考虑进去）。</li>
</ul>
<h2 id="Grey-box-FCS-Algorithms"><a href="#Grey-box-FCS-Algorithms" class="headerlink" title="Grey-box FCS Algorithms"></a>Grey-box FCS Algorithms</h2><ul>
<li>灰盒用到的反馈信息：黑盒能用到的，达到的覆盖率等等</li>
<li>AFL认为执行最快，input最少的是<strong>fit</strong></li>
<li><p>AFLFast在AFL基础上做了三点改进</p>
<ul>
<li>增加两条重要准则：<ul>
<li>AFLFast喜欢被选中<strong>最少</strong>的配置</li>
<li>AFLFast喜欢<strong>最少</strong>选择的路径</li>
</ul>
</li>
<li>AFLFast在AFL增加了优先级，替代AFL中的圆形选择</li>
<li>AFLFast每个配置被选中次数是动态改变的</li>
</ul>
</li>
<li><p>AFLGo修改了AFLFast优先级的特征，目的是为了找到特定的程序位置。</p>
</li>
</ul>
<h1 id="INPUT-GENERATION"><a href="#INPUT-GENERATION" class="headerlink" title="INPUT GENERATION"></a>INPUT GENERATION</h1><ul>
<li>分为generation-based和mutation-based，前者是基于model的，后者是通过mutate seed。</li>
</ul>
<h2 id="Model-based-Generation-based-Fuzzers"><a href="#Model-based-Generation-based-Fuzzers" class="headerlink" title="Model-based (Generation-based) Fuzzers"></a><strong>Model-based (Generation-based) Fuzzers</strong></h2><ul>
<li>预定义或用户提供的模型</li>
<li>推断模型可能发生在PREPROCESS阶段也可能在CONFUPDATE阶段<ul>
<li>在PREPROCESS阶段，在PUT中搜找可用的数据（如文字），去预测合适的输出</li>
<li>在CONFUPDATE阶段，每次迭代更新model</li>
</ul>
</li>
<li>编译器模型（不太能理解这个模型）<ul>
<li>解析特定的文件格式</li>
</ul>
</li>
</ul>
<h2 id="Model-less-Mutation-based-Fuzzers"><a href="#Model-less-Mutation-based-Fuzzers" class="headerlink" title="Model-less (Mutation-based) Fuzzers"></a><strong>Model-less (Mutation-based) Fuzzers</strong></h2><ul>
<li>需要seed-based输入生成和<strong>白盒输入生成</strong>。</li>
<li>Bit-flipping：翻转固定/不固定数量bit位，用mutation ratio决定翻转多少数量的bit位。因此，找到一个合适的mutation ratio数值至关重要。</li>
<li><em>Arithmetic Mutation</em>：将选择的字节序列视为一个整数，对整数进行处理（不太能理解）</li>
<li><em>Block-based Mutation</em>：以block为单位，进行mutation</li>
<li><em>Dictionary-based Mutation</em>：对具体的字符（数值）进行mutation（不太能理解）</li>
</ul>
<h2 id="White-box-Fuzzers"><a href="#White-box-Fuzzers" class="headerlink" title="White-box Fuzzers"></a>White-box Fuzzers</h2><ul>
<li><p>先使用白盒程序分析找到PUT的信息，用这信息去进行黑盒or灰盒fuzzing。</p>
</li>
<li><p>Dynamic symbolic execution：比灰盒和黑盒慢很多，因为它需要对PUT的每条指令进行插桩和分析，这方面的研究都聚集在如何减少它的代价方面。</p>
</li>
<li><p><em>Guided Fuzzing</em>：先对PUT进行分析（静态or动态分析）来获取有用的信息；再利用这个信息去生成test case。这上面的研究一方面需要减少分析产生的代价。</p>
</li>
<li><p><em>PUT Mutation</em>：不重要。。</p>
</li>
</ul>
<h1 id="INPUT-EVALUATION"><a href="#INPUT-EVALUATION" class="headerlink" title="INPUT EVALUATION"></a>INPUT EVALUATION</h1><h2 id="Bug-Oracles"><a href="#Bug-Oracles" class="headerlink" title="Bug Oracles"></a><strong>Bug Oracles</strong></h2><ul>
<li>有三个方面的侦测：内存安全问题（是否访问到不安全的内存、控制流的完整性[啥意思]）、访问到未被定义的行为（如编译器不同，程序猿只考虑了某些编译器情况下可行，但有些不可行却忽略了）、输入的合法性（比如<strong>SQL访问可能对数据库引擎存在一些破坏</strong>）</li>
</ul>
<h2 id="Execution-Optimizations"><a href="#Execution-Optimizations" class="headerlink" title="Execution Optimizations"></a><strong>Execution Optimizations</strong></h2><ul>
<li>由于迭代需要每次都初始化PUT进程，需要耗费大量的时间，对此，AFL提供了一个fork-server去让迭代去从进行初始化好的进行进程中fork一下。</li>
</ul>
<h2 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h2><ul>
<li>分析和报告导致违反政策（感觉就是不安全的）的进程，分为三步：去重复、优先级、测试样例最小化。</li>
</ul>
<h3 id="Deduplication"><a href="#Deduplication" class="headerlink" title="Deduplication"></a>Deduplication</h3><ul>
<li>去重复：若该test case返回的Bug已经被以前的test case找到了，这个test case就不要了。能得到test case集合，该集合中每个test case都能触发唯一的bug。去重复有三种主要的实现方式：<ul>
<li>stack backtrace hashing<ul>
<li>记录了crash时的stack backtrace(如：main → d → c → b → a → foo )，当其他crash时的stack backtrace的后五个也是这个时候，认为他们重复, 这是major hash。而minor hash还考虑到line number（感觉是数量）。但这样做事基于一种假设，即相似的crash是由相似的bugs引起的，但这假设未被验证，且能举出反例。</li>
</ul>
</li>
<li>coverage-based deduplication<ul>
<li>在PUT中插桩记录PUT每次执行的edge覆盖率，根据这个信息选取seeds，AFL认为当crash覆盖到之前未见到的edge或者未覆盖到之前在所有其他crashes中都覆盖到的edge时，认为该crash是唯一的。</li>
</ul>
</li>
<li>semantics-aware deduplication<ul>
<li>从每个crash处反向分析，找到那个function，根据function来对crashes进行分类。(怎么那么奇怪)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>### </p>
<h3 id="Prioritization-and-Exploitability"><a href="#Prioritization-and-Exploitability" class="headerlink" title="Prioritization and Exploitability"></a>Prioritization and Exploitability</h3><ul>
<li><p>根据一个crash的可利用性来划分优先级。Microsoft’s !exploitable的优先级划分： EXPLOITABLE &gt; PROBABLY_EXPLOITABLE &gt; UNKNOWN &gt;</p>
<p>NOT_LIKELY_EXPLOITABLE,</p>
</li>
</ul>
<h3 id="Test-case-minimization"><a href="#Test-case-minimization" class="headerlink" title="Test case minimization"></a>Test case minimization</h3><ul>
<li>利用bug oracle进行test case 最小化。许多fuzzers都针对自己特定的情况选用test case最小化算法。</li>
</ul>
<h1 id="CONFIGURATION-UPDATING"><a href="#CONFIGURATION-UPDATING" class="headerlink" title="CONFIGURATION UPDATING"></a>CONFIGURATION UPDATING</h1><ul>
<li>可用来区别是白盒fuzzer、黑盒fuzzer、灰盒fuzzer。由于黑盒只能用到Oracle bug(不能得到PUT的内部信息)大部分Conf都不被修改。</li>
</ul>
<h2 id="Evolutionary-Seed-Pool-Update"><a href="#Evolutionary-Seed-Pool-Update" class="headerlink" title="Evolutionary Seed Pool Update"></a>Evolutionary Seed Pool Update</h2><ul>
<li>灰盒fuzzer大多基于遗传算法进行展开，EA-based fuzzers大多数使用node或者Branch覆盖度作为fitness function.[后面举例没仔细看]</li>
</ul>
<h2 id="Maintaining-a-Minset"><a href="#Maintaining-a-Minset" class="headerlink" title="Maintaining a Minset"></a>Maintaining a Minset</h2><ul>
<li>赋予favorable fuzzing conf以高的被选择进行fuzzing的权重。思想是：需要少的test case最大化coverage评价指标。</li>
</ul>
<p>​    </p>
<h1 id="Links"><a href="#Links" class="headerlink" title="Links:"></a>Links:</h1><ul>
<li>paper: <a href="https://ieeexplore.ieee.org/abstract/document/8863940" target="_blank" rel="noopener">https://ieeexplore.ieee.org/abstract/document/8863940</a></li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/" itemprop="url">Detect logic bugs in DBMS的三篇论文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-13T20:27:12Z">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DBMS-Testing/" itemprop="url" rel="index">
                    <span itemprop="name">DBMS Testing</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Testing-Database-Engines-via-Pivoted-Query-Synthesis论文"><a href="#Testing-Database-Engines-via-Pivoted-Query-Synthesis论文" class="headerlink" title="Testing Database Engines via Pivoted Query Synthesis论文"></a>Testing Database Engines via Pivoted Query Synthesis论文</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>随机生成table和rows</li>
<li>从每个表随机生成<strong>一行</strong></li>
<li>根据选择的rows随机生成表达式并评估结果</li>
<li>修改表达式 直到返回真</li>
</ul>
<h2 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h2><ul>
<li>检测logic bug，logic bug即是否返回正常的行</li>
</ul>
<h2 id="研究常用的方法"><a href="#研究常用的方法" class="headerlink" title="研究常用的方法"></a>研究常用的方法</h2><ul>
<li><p>差异性测试，不适用于所有DBMS</p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202218604.png" alt="image-20200618202218604"></p>
</li>
</ul>
<h2 id="各项性能指标"><a href="#各项性能指标" class="headerlink" title="各项性能指标"></a>各项性能指标</h2><ul>
<li>观察是否返回 随机生成的row</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不适用于大数据集</li>
<li>可能只能做where里面的AST树</li>
</ul>
<h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><ul>
<li>AST树</li>
<li>差异性比较</li>
</ul>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202406294.png" alt="image-20200618202406294"></p>
<h1 id="Detecting-Optimization-Bugs-in-Database-Engines-via-Non-Optimizing-Reference-Engine-Construction论文"><a href="#Detecting-Optimization-Bugs-in-Database-Engines-via-Non-Optimizing-Reference-Engine-Construction论文" class="headerlink" title="Detecting Optimization Bugs in Database Engines via Non-Optimizing Reference Engine Construction论文"></a>Detecting Optimization Bugs in Database Engines via Non-Optimizing Reference Engine Construction论文</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>不正常的优化可能会导致logic bug</p>
</li>
<li><p>核心：重写DBMS不能优化的潜在随机生成优化的query</p>
</li>
<li><p>让DBMS不做优化，做全表的扫描</p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618192500114.png" alt="image-20200618192500114"></p>
<ul>
<li>左边是原本数据库会优化的，右边是数据库不会优化的。</li>
</ul>
</li>
<li><p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202756024.png" alt="image-20200618202756024"></p>
</li>
</ul>
<h1 id="Ternary-Logic-Partitioning-Detecting-Logic-Bugs-in-Database-Management-Systems"><a href="#Ternary-Logic-Partitioning-Detecting-Logic-Bugs-in-Database-Management-Systems" class="headerlink" title="Ternary Logic Partitioning: Detecting Logic Bugs in Database Management Systems"></a>Ternary Logic Partitioning: Detecting Logic Bugs in Database Management Systems</h1><h2 id="主要内容-2"><a href="#主要内容-2" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>query分区，将一条给定原始的query，分成多份更复杂的queries，每个部分都计算结果的一部分。</li>
<li><p>三元逻辑分区：</p>
<ul>
<li>基于一个布尔谓词p计算成True,False,NULL的观察</li>
</ul>
</li>
<li><p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618192837917.png" alt="image-20200618192837917"></p>
</li>
</ul>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618203712878.png" alt="image-20200618203712878"></p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618203725136.png" alt="image-20200618203725136"></p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/" itemprop="url">Automated Grading of SQL Queries 论文解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-20T10:50:42Z">
                2020-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL-Queries-Paper/" itemprop="url" rel="index">
                    <span itemprop="name">SQL Queries Paper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul>
<li><p>自动给学生的sql query打分，局部打分，通过判断错误严重的程度。</p>
</li>
<li><p>采用 <strong>weighted equivalence edit distance metric</strong>，找到最小的编辑序列，能将原始错误的sql query转为正确的query。</p>
</li>
<li><p>使用query规范化规则针对语法和语义进行规划</p>
<ul>
<li>语法，如将Not(A&gt;B) 替换为A&lt;=B; 将操作构建一棵flattened tree</li>
<li>语义，将query中主键上的distinct移除，将query中冗余的关系移除。</li>
</ul>
</li>
<li><p>Flattened Tree Structure</p>
<p><img src="/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/image-20200620103146416.png" alt="image-20200620103146416.png"></p>
<ul>
<li>将query中有连接关系的都flatten一下，转化为等价形式。</li>
<li>针对flattened tree，谓词/投影/聚类操作都作为一棵棵子树</li>
</ul>
</li>
<li><p>计算规范化的编辑距离</p>
<ul>
<li>对于每个组件（子树）分别计算编辑距离，然后找到每个quert的带权距离。Σc∈<em>components</em>W<strong>c <em>∗</em> E</strong>c</li>
</ul>
</li>
<li><p>根据编辑距离给分</p>
</li>
</ul>
<h1 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h1><ul>
<li>指出错误sql query错在那个部分，也就是做最小的改动，能让sql query变成正确的。</li>
</ul>
<h1 id="研究常用的方法"><a href="#研究常用的方法" class="headerlink" title="研究常用的方法"></a>研究常用的方法</h1><ul>
<li>XData通过比较正确query和学生query得到的结果，对学生 sql query进行二分类，即判别正确or错误，但太简单了，想得到更细致的。</li>
<li>根据正确query和学生query返回结果交集所占正确结果的比例，但有可能因为一个很小的错误得出的结果很差，导致分数低。</li>
<li>学生的sql query需要做<strong>多少个变化</strong>才能和正确的sql等价，但许多具有语义差异的sql在返回的结果却没什么差异。<strong>（本文）</strong>针对此，使用大量query规范化技巧移除学生和正确的queries的不相关的语法和语义差别。但是需要给出多个正确的queries，将学生query与其相比较，选出匹配度最高的query。这个问题可以抽象为图中找最短路径，提出一个贪心启发性技巧。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>基于规范化编辑距离的给分有可能是不公平的，在规范化部分还存在一些问题。</li>
</ul>
<h1 id="实验部分和讨论部分"><a href="#实验部分和讨论部分" class="headerlink" title="实验部分和讨论部分"></a>实验部分和讨论部分</h1><ul>
<li><p>随机创建一对不正确的学生queries，a和b，让两个志愿者对每对queries分类，第一类是a queriy的分高，第二类是b query的分高，第三类是a,b query的分数一样高。</p>
</li>
<li><p>potentially an infinite number of edit options <strong>are possible</strong></p>
</li>
</ul>
<h1 id="对负载生成的启发点"><a href="#对负载生成的启发点" class="headerlink" title="对负载生成的启发点"></a>对负载生成的启发点</h1><h2 id="SQL-QUERY-规范化"><a href="#SQL-QUERY-规范化" class="headerlink" title="SQL QUERY 规范化"></a>SQL QUERY 规范化</h2><ul>
<li><p>B. Chandra, M. Joseph, B. Radhakrishnan, S. Acharya, and S. Sudarshan.</p>
<p>Partial marking for automated grading of SQL queries. <em>PVLDB (Demo)</em>,</p>
<p>9(13):1541–1544, 2016.</p>
</li>
</ul>
<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><ul>
<li><a href="https://www.cse.iitb.ac.in/infolab/xdata" target="_blank" rel="noopener">https://www.cse.iitb.ac.in/infolab/xdata</a></li>
<li><a href="https://gitlab.com/xdata/xdata-web/-/tree/developer/XDataGrading/src" target="_blank" rel="noopener">https://gitlab.com/xdata/xdata-web/-/tree/developer/XDataGrading/src</a></li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/05/06/Hadoop分布式文件系统（HDFS）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/06/Hadoop分布式文件系统（HDFS）/" itemprop="url">Hadoop分布式文件系统（HDFS）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-05-06T12:10:31Z">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/分布式模型与编程/" itemprop="url" rel="index">
                    <span itemprop="name">分布式模型与编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="设计考量"><a href="#设计考量" class="headerlink" title="设计考量"></a>设计考量</h1><h2 id="HDFS设计假设、目标"><a href="#HDFS设计假设、目标" class="headerlink" title="HDFS设计假设、目标"></a>HDFS设计假设、目标</h2><ul>
<li>硬件失效<ul>
<li>硬件的异常比软件的异常更加常见</li>
</ul>
</li>
<li>流式数据访问<ul>
<li>Dataflow</li>
<li>hdfs是量身定制，并非以通用业务为目的</li>
<li>关注吞吐量，并非响应时间</li>
</ul>
</li>
<li><p>存储数据较大</p>
</li>
<li><p>简化的数据一致性模型</p>
<ul>
<li>数据写入之后，不允许再修改了，只允许在后面追加</li>
</ul>
</li>
<li>多硬件平台支持<ul>
<li>易于运行不同的平台上（故用java编写）</li>
</ul>
</li>
<li>移动计算能力比移动数据更划算<ul>
<li>计算和存储采用就近原则，计算离数据最近</li>
<li>移动计算就是移动代码，对远程的数据进行计算</li>
</ul>
</li>
</ul>
<h2 id="如何应对大文件"><a href="#如何应对大文件" class="headerlink" title="如何应对大文件"></a>如何应对大文件</h2><h3 id="文件由数据块集合组成"><a href="#文件由数据块集合组成" class="headerlink" title="文件由数据块集合组成"></a>文件由数据块集合组成</h3><ul>
<li>通常每块大小为64MB</li>
<li>与os的块的区别：<ul>
<li>os的目的：省io的时间、不满还是会占整个block的大小的</li>
<li>hdfs目的：把大的文件切小、不满是不会占64mb的</li>
</ul>
</li>
</ul>
<h2 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h2><ul>
<li>跨机器索引</li>
</ul>
<h1 id="HDFS-架构"><a href="#HDFS-架构" class="headerlink" title="HDFS 架构"></a>HDFS 架构</h1><h2 id="HDFS节点类型"><a href="#HDFS节点类型" class="headerlink" title="HDFS节点类型"></a>HDFS节点类型</h2><ul>
<li>NameNode      每个集群一个名字节点（master）<ul>
<li>负责文件系统元数据操作、数据块的复制和定位</li>
</ul>
</li>
<li>SecondaryNamenode       NameNode的备份</li>
<li>Datanode</li>
</ul>
<h2 id="NameNode-："><a href="#NameNode-：" class="headerlink" title="NameNode ："></a>NameNode ：</h2><ul>
<li>作用：管理节点、接收用户的操作请求</li>
<li>核心数据文件包括：<ul>
<li>元数据镜像文件fsimage: 维护文件系统树以及文件树中所有的文件/目录的元数据</li>
<li>操作日志文件EditLog: 记录所有针对文件的创建、删除、重命名等操作。<ul>
<li>如果元数据镜像文件可以承受恢复的代价，那么日志也可以不需要了，日志为了减轻元数据镜像文件的负担。</li>
</ul>
</li>
</ul>
</li>
<li>元数据保存在内存中</li>
<li>做了block和datanode之间的映射关系</li>
</ul>
<h2 id="SecondaryNameNode"><a href="#SecondaryNameNode" class="headerlink" title="SecondaryNameNode"></a>SecondaryNameNode</h2><ul>
<li>执行过程：<ul>
<li>定期从Namenode上下载fsimage,edits，二者合并，生成新的fsimage</li>
<li>在本地保存，并写回NameNode</li>
</ul>
</li>
<li>它是“检查点”，而不是“热备份”（即并非实时备份）</li>
</ul>
<h2 id="DataNode"><a href="#DataNode" class="headerlink" title="DataNode"></a>DataNode</h2><ul>
<li>作用：一共文件的存储</li>
<li>文件块：一个Linux文件</li>
<li>HDFS中，如果一个文件小于一个数据块的大小，并不占用整个数据块存储空间</li>
<li>数据备份：默认是三个</li>
<li>文件内容保存在磁盘</li>
</ul>
<h1 id="文件访问"><a href="#文件访问" class="headerlink" title="文件访问"></a>文件访问</h1><h2 id="文件写入HDFS"><a href="#文件写入HDFS" class="headerlink" title="文件写入HDFS"></a>文件写入HDFS</h2><ul>
<li>NameNode 告知客户端文件的每一个数据块存储在何处<br>b. 客户端将数据块直接传输到指定的数据节点数据访问</li>
</ul>
<h2 id="从HDFS读取文件"><a href="#从HDFS读取文件" class="headerlink" title="从HDFS读取文件"></a>从HDFS读取文件</h2><ul>
<li>从NameNode 返回每个数据块的位置给客户端</li>
<li>从数据节点上传数据块（不同的数据块可以并行读取）</li>
</ul>
<h3 id="数据读取策略"><a href="#数据读取策略" class="headerlink" title="数据读取策略"></a>数据读取策略</h3><h3 id="文件访问模型"><a href="#文件访问模型" class="headerlink" title="文件访问模型"></a>文件访问模型</h3><ul>
<li>“一次写入多次读取”<ul>
<li>修改内容需删除，重新写入</li>
<li>仅允许追加append()  <ul>
<li>注： 此为追加一个block，而不是在原来的block追加内容</li>
</ul>
</li>
</ul>
</li>
<li>好处：避免读写冲突，无需文件锁</li>
</ul>
<h3 id="HDFS数据备份"><a href="#HDFS数据备份" class="headerlink" title="HDFS数据备份"></a>HDFS数据备份</h3><h1 id="备份与一致性"><a href="#备份与一致性" class="headerlink" title="备份与一致性"></a>备份与一致性</h1><ul>
<li><p>一个文件有若干备份</p>
</li>
<li><p>备份之间是否可能不一致？</p>
<ul>
<li>同时append两个备份</li>
</ul>
</li>
</ul>
<h1 id="容错机制"><a href="#容错机制" class="headerlink" title="容错机制"></a>容错机制</h1><ul>
<li><p>HDFS在设计时就考虑到故障（硬件和软件）会经常出现</p>
</li>
<li><p>DataNode故障：</p>
<ul>
<li>“宕机”：节点上面的所有数据都会被标记为“不可读”</li>
<li>定期检查备份因子</li>
</ul>
</li>
<li><p>NameNode故障</p>
<ul>
<li>根据SecondaryNameNode中的Fslmage和Editlog数据进行恢复</li>
</ul>
</li>
<li><p>其他故障</p>
<ul>
<li>磁盘错误或故障：数据校验</li>
<li>交换机/机架故障</li>
<li>数据中心故障</li>
</ul>
</li>
</ul>
<h1 id="HDFS功能"><a href="#HDFS功能" class="headerlink" title="HDFS功能"></a>HDFS功能</h1><ul>
<li><p>适用：</p>
<ul>
<li>大文件存储、流式数据访问</li>
</ul>
</li>
<li><p>不合适:</p>
<ul>
<li>大量小文件（无法完美利用数据并行读取）</li>
<li>随机读取（因为有固定的代价）</li>
<li>低延迟读取</li>
</ul>
</li>
</ul>
<p>​        </p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="luyiqu">
            
              <p class="site-author-name" itemprop="name">luyiqu</p>
              <p class="site-description motion-element" itemprop="description">blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">25</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyiqu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>

<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="瞿璐祎的博客" type="application/atom+xml">






<meta name="description" content="blog">
<meta name="keywords" content="个人博客">
<meta property="og:type" content="website">
<meta property="og:title" content="瞿璐祎的博客">
<meta property="og:url" content="https://luyiqu.github.io/index.html">
<meta property="og:site_name" content="瞿璐祎的博客">
<meta property="og:description" content="blog">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="瞿璐祎的博客">
<meta name="twitter:description" content="blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>




  <link rel="canonical" href="https://luyiqu.github.io/">





  <title>瞿璐祎的博客</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">瞿璐祎的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">try something new</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>
            
            Schedule
          </a>
        </li>
      

      
    </ul>
  

  
</nav>






 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/28/NewSQL/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/28/NewSQL/" itemprop="url">What’s Really New with NewSQL</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-27T16:06:22Z">
                2020-08-27
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Paper/" itemprop="url" rel="index">
                    <span itemprop="name">Paper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<hr>
<h1 id="先导"><a href="#先导" class="headerlink" title="先导"></a>先导</h1><h2 id="为什么需要NewSQL"><a href="#为什么需要NewSQL" class="headerlink" title="为什么需要NewSQL?"></a>为什么需要NewSQL?</h2><ul>
<li>数据的急速扩增，需要数据库具有很强的扩展性，往往有两种扩展方式：<ul>
<li>垂直扩展：scale-up</li>
<li>水平扩展: scale-out，采用中间件，做sharding的方式，即分库分表的方式</li>
</ul>
</li>
</ul>
<h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><h3 id="代表性的DB"><a href="#代表性的DB" class="headerlink" title="代表性的DB"></a>代表性的DB</h3><ul>
<li>Google’s BigTable — HBASE（开源版）</li>
<li>Amazon’s Dynamo — Cassandra（开源版）</li>
<li>MongoDB</li>
<li>Redis(键值型数据库)</li>
</ul>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li>不保证强一致性（故不适用金融服务），需要在应用逻辑里处理最终一致性的问题</li>
<li>不支持事务</li>
<li>数据模型：键值对、图形、文档</li>
</ul>
<h2 id="NewSQL"><a href="#NewSQL" class="headerlink" title="NewSQL"></a>NewSQL</h2><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><ul>
<li>可扩展性</li>
<li>针对读写事务需要满足：<ul>
<li>执行时间短</li>
<li>一般只查询一小部分数据，通过使用索引来达到高效查询的目的，即避免全表扫描或者大规模的分布式join</li>
<li>一般执行相同的命令，<strong>使用不同的输入参数</strong></li>
</ul>
</li>
</ul>
<h1 id="数据库的历史"><a href="#数据库的历史" class="headerlink" title="数据库的历史"></a>数据库的历史</h1><h2 id="early-1970s"><a href="#early-1970s" class="headerlink" title="early 1970s"></a>early 1970s</h2><ul>
<li>IBM’s SystemR</li>
<li>the University of California’s INGRES</li>
<li>Oracle(和系统R的设计很像)  </li>
<li>DB2 1983</li>
</ul>
<h2 id="late-1980s-and-early-1990s"><a href="#late-1980s-and-early-1990s" class="headerlink" title="late 1980s and early 1990s"></a>late 1980s and early 1990s</h2><ul>
<li>出现面向对象的数据库（但夭折了），不过他的思想延续了，如加入对象和XML</li>
<li>MYSQL 1995</li>
<li>PostgreSQL 1994</li>
</ul>
<h2 id="2000s"><a href="#2000s" class="headerlink" title="2000s"></a>2000s</h2><ul>
<li>2000s，随着互联网的应用越来越多，对数据库的要求也高起立了，针对这个，有一部分人提出将数据库<strong>scale-up</strong>，一直更新数据库的硬件资源，不断升级。</li>
<li>另一部分提出了使用一个定制的<strong>中间件</strong>，在一组便宜的机器上构建单节点的DBMS，主要是中间件的功劳！！（感觉这个接近现在newsql的概念），中间件需要做的事情可多了，对应用端不偏于访问数据库的queries进行重写，之后再发给底下的机器上，让它们执行完返回，之后中间件再结合它们的合并他们的返回结果给应用端。能力大了，担子也就自然大了，因此导致中间件这个节点负载过大，产生性能瓶颈（这是我自己的想法）<ul>
<li>中间件的典型：<ul>
<li>Google’s MySQL-based cluster（这方法被Facebook采取，至今仍在使用）</li>
<li>eBay’s Oracle-based cluster（join贼不方便。ebay要求开发人员在应用层自己去实现Join)</li>
</ul>
</li>
</ul>
</li>
<li>最终，提出分布式DBMSs，因为传统数据库关注一致性和正确性的同时，忽视了可用性和性能，但这种trade-off对于如今的互联网应用来说却是不合适的。而且使用full-featured DBMS(像MySQL)开销很大（限制太多）</li>
</ul>
<h2 id="mid-to-late-2000s"><a href="#mid-to-late-2000s" class="headerlink" title="mid to late 2000s"></a>mid to late 2000s</h2><ul>
<li>NoSQL出现了，他们放弃了<strong>强事务保证</strong>和传统数据库中的<strong>关系模型</strong>，选择了<strong>最终一致性</strong>和<strong>可选择的数据模型</strong>（key/value,graphs,documents)</li>
<li>代表：<ul>
<li>Google’s BigTable（未开源）</li>
<li>Amazon’s Dynamo（未开源）</li>
<li>Facebook’s Cassandra(基于BigTable &amp; Dynamo)</li>
<li>PowerSet’s Hbase(基于BigTable)</li>
<li>MongoDB</li>
</ul>
</li>
<li>NoSQL的好处是开发人员会更关注他们的应用场景而并非如何去扩展数据库</li>
<li>但一些机构（如Google）发现NoSQL会导致他们的开发人员耗费太长时间去处理数据一致性和事务。这些机构职能要么去scale-up机器，要么使用他们自己的定制化的中间层去支持事务。</li>
</ul>
<h2 id="NEWSQL"><a href="#NEWSQL" class="headerlink" title="NEWSQL"></a>NEWSQL</h2><ul>
<li>既想拥有NoSQL一样的<strong>可扩展性</strong>，又想保持传统数据库中的<strong>关系模型</strong>和<strong>事务支持</strong></li>
<li>NewSQL DBMSs 读写事务的特点：<ul>
<li>short-lived</li>
<li>只用到少部分的数据集（使用索引）</li>
<li>事务模板重复（只修改输入参数值）</li>
</ul>
</li>
<li>NewSQL 有更狭窄的定义：<ul>
<li>a lock-free concurrency control schema</li>
<li>a shared-nothing distributed architecture</li>
</ul>
</li>
</ul>
<h1 id="NewSQL的分类"><a href="#NewSQL的分类" class="headerlink" title="NewSQL的分类"></a>NewSQL的分类</h1><ul>
<li>使用新架构的新系统</li>
<li>重新实现2000s由Google等开发的中间层基础设施</li>
<li>由云计算提供的数据库即服务</li>
</ul>
<p>注：以上的这些之前都提出新的存储引起去取代mysql默认的innoDB，只改变引擎的话就不需要改变API，但是作者认为mysql的InnoDB可靠且性能好，如果改变InnoDB的存储引擎是为了将行存换成列存，如OLAP的话是可以接受的（如Infobright,InfiniDB)。但还是OLTP事务的话换掉InnoDB引擎是没有什么意义的。</p>
<h2 id="新的架构"><a href="#新的架构" class="headerlink" title="新的架构"></a>新的架构</h2><ul>
<li>都有以下几个特征：<ul>
<li>基于分布式架构在shared-nothing resources，且包括以下组件：支持多节点并发控制、冗余容错、流控制、分布式查询处理，且包括节点之间的查询优化和交流协议（如节点和节点之间直接send intra-query data，不需要经过统一的中间层）</li>
<li>DBMSs都自己管理他们的主要存储（无论是在内存还是在磁盘上），不依赖HDFS等系统，这个特性是为了实现query落在数据节点，减少传送代价。</li>
<li>当然也有缺点，新的架构想必采用了新的技术，但对于这些技术大多人都不熟悉，那对应的管理数据库和报告工具也就还没有啦~针对此，Clstrix和MemSOL和MYSQL wire protocol维持兼容性。</li>
</ul>
</li>
<li>本类案例：Clustrix, Cockroach, Google Spanner, H-Store, HyPer, MemSQL, NuoDB, SAP HANA, VoltDB.</li>
</ul>
<h2 id="透明的分表中间件"><a href="#透明的分表中间件" class="headerlink" title="透明的分表中间件"></a>透明的分表中间件</h2><ul>
<li>分表的特性：<ul>
<li>每个节点都跑同一个数据库</li>
<li>每个节点仅是数据库的一部分</li>
<li>每个节点都不能被应用独立访问</li>
</ul>
</li>
<li>中间件组织查询，安排事务，管理每个节点的数据分布、复制、分割。</li>
<li>有个shim layer装在每个数据库节点上和中间层交流，它主要负责代表中间件去执行本地的查询并返回给中间件结果。</li>
<li>中间件的优点：使用人员都感觉使用的是同一个节点的数据库。</li>
<li>mysql就使用中间件去扩展，因此中间件需要支持mysql wire protocol</li>
<li>很多组织的确是使用了中间件，但每个节点都使用传统的数据库（如mysq），这样他们都不能使用存储管理器或者并发控制schema。而且中间件不得不先去优化一下查询计划再分发给不同的数据库节点。（每个节点自己也会优化中间件派发给自己的查询）</li>
<li>本类案例：AgilData Scalable Cluster, MariaDB MaxScale, ScaleArc, ScaleBase.</li>
</ul>
<h2 id="数据库即服务"><a href="#数据库即服务" class="headerlink" title="数据库即服务"></a>数据库即服务</h2><ul>
<li>如今，很多云计算都提供NewSQL 数据库即服务，也就是开发人员不需要自己去配置资源等等啥的，只要会使用就好了。交付给用户的只是一个连接DBMS的URL，以及一个用于监控的仪表盘页面或者一组用于系统控制的API。</li>
<li><p>本文只认为在2016年止只有两款可以认为是NewSQL，分别是Amazon’s Aurora（利用日志结构存储管理来优化I/O并发度）和ClearDB提供定制化的DBaaS部署在主要的云平台上。<strong>【不太清楚ClearDB】</strong></p>
</li>
<li><p>本类案例：Amazon Aurora，ClearDB</p>
</li>
</ul>
<h1 id="NewSQL的新技术"><a href="#NewSQL的新技术" class="headerlink" title="NewSQL的新技术"></a>NewSQL的新技术</h1><h2 id="主存存储器"><a href="#主存存储器" class="headerlink" title="主存存储器"></a>主存存储器</h2><ul>
<li>基于内存存储的NewSQL DBMS有学术的（H-Store,HyPer）也有商用的（MemSQL,SAP HAHA,VoltDB)</li>
<li>将数据库全部存储在内存上实质在1980s就被提出来了，那个时候，PRISMA/DB（首个分布式内存DBMS也被开发出来了），Altibase,Oracle’s TimesTen,AT&amp;T’s DataBlitz是其组件。</li>
<li>基于内存存储器的NewSQL新就新在它可以将数据库的一部分（比如冷数据）驱逐到磁盘中，也就是说基于内存存储器的NewSQL也可以支持比内存大的数据库了。<ul>
<li>实现这个通用方法是使用一个<strong>数据库内部的internal tracking mechanism</strong>来挑选出冷数据。</li>
<li>此外，还有一个方法是EPFL中使用VoltDB的<strong>OS虚拟内存页</strong>。</li>
<li>MemSQL,管理器手动创建数据库去以列存的方式存储table。它以log-structured storage方式去减少update的开销。</li>
</ul>
</li>
</ul>
<h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><ul>
<li>最早的分布式数据库是SSD-1 project 1970，在1980s system R和INGRES也创建了各自的分布式版本，前者是一个shared-nothing，基于磁盘的分布式数据库，后者由于它的动态查询优化算法得以出名，它把分布式查询切割成小块。</li>
<li>但以上分布式数据库都没有啥进展有以下两点原因<ul>
<li>机器太贵了，分布式机器代价大</li>
<li>那个时候由于应用都很简单，对分布式高性能的数据库没什么追求。</li>
</ul>
</li>
<li>partition怎么做？<ul>
<li>将数据库的table水平分到几个节点中，可以根据数据的columns，或者具体的values（如根据一个customer的id，做个range or hash partitioning分在节点中，然后对应的order啥的也根据id进行划分，这样尽可能保证一个事务在一个节点上进行查询，避免分布式事务），但是Amazon Aurora，ClearDB去不支持这样的partition【为啥呢】</li>
<li>据库schema可以转换为树状结构，树的后代与根具有外键关系。然后依据这些关系关联的属性对表进行分区，使得单个实体的所有数据都能位于同一分区。例子：一个树的根节点可能是一个客户表，数据库将会根据每一个客户进行分区，将每个人的订单记录和账户信息存放在一起。</li>
</ul>
</li>
<li>有两种cluster node架构，分别是同质的和异质的<ul>
<li>同质：数据和执行都放在一个节点上。</li>
<li>异质：数据和执行节点分离</li>
</ul>
</li>
</ul>
<h3 id="异质节点架构"><a href="#异质节点架构" class="headerlink" title="异质节点架构"></a>异质节点架构</h3><h4 id="NuoDB"><a href="#NuoDB" class="headerlink" title="NuoDB"></a>NuoDB</h4><ul>
<li><p>存储节点（SM）：将数据库分为多个blocks(atoms)</p>
</li>
<li><p>事务引擎节点（TEs）：作为atoms的内存缓冲</p>
<ul>
<li>需要write-locks on tuples，然后对tuples的修改都会去广播给其他的TEs和SM</li>
<li>为避免nodes之间的来回，NuoDB公开负载均衡schema确保使用的数据会驻留在同一个TE中</li>
<li>和其他的分布式数据库一样都需要partitioning schema，但不需要pre-partition数据库以及定义table之间的关系（为啥不需要？）</li>
</ul>
</li>
</ul>
<h4 id="MemSQL"><a href="#MemSQL" class="headerlink" title="MemSQL"></a>MemSQL</h4><ul>
<li><p>只具备<strong>执行功能的聚合器节点</strong>和<strong>存储实际数据的叶节点</strong></p>
</li>
<li><p>execution-only aggregator nodes：不缓冲任务数据</p>
</li>
<li>存储真实数据的叶子节点：会执行部分queries，从而也减少返回给aggregator节点的数据。而在NuoDB中SM就只是存储数据的节点。</li>
</ul>
<h3 id="实时迁移"><a href="#实时迁移" class="headerlink" title="实时迁移"></a>实时迁移</h3><ul>
<li>物理资源会迁移数据，和NoSQL中的re-balancing很像，但在迁移的过程中NewSQL会确保事务的ACID。有两个方法保证实现这点。<ul>
<li>以粗粒度的虚拟(逻辑)分区来组成数据库 分布在不同的物理节点上。当DBMS需要re-balance的时候，就移动节点之间的这些虚拟分区。<ul>
<li>Clustrix(NewSQL)，AgilData(NewSQL),Cassandra(NoSQL),DynamoDB(NoSQL)就使用这个方法。</li>
</ul>
</li>
<li>执行细粒度的re-balancing通过range partitioning重新分配tuples和tuples组。很像MongoDB中的auto-sharding feature。ScaleBase和H-Store常用这方法。</li>
</ul>
</li>
</ul>
<h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><ul>
<li>需要保证原子性和隔离性</li>
<li>主要有两种协调器：集中式或去中心化事务协商<ul>
<li>集中式的：由一个协调器节点专门管这个事情，所有事务操作都要经过它。在1970-1980s的TP monitors这个方法就被提出了</li>
<li>去中心化的：每个节点都保持一定的事务状态（访问其节点数据的），节点之间会相互协商来避免并发事务冲突。<ul>
<li>优点：便于scalability</li>
<li>缺点：需要记录DBMS节点的时钟来保证高同步，从而生成全局有序的事务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="分布式架构"><a href="#分布式架构" class="headerlink" title="分布式架构"></a>分布式架构</h3><h4 id="2PL"><a href="#2PL" class="headerlink" title="2PL"></a>2PL</h4><ul>
<li>SSD-1 由中心化的协调器管理shared-nothing nodes。</li>
<li>IBM’s R*是去中心化协调器协调的，它使用了分布式的2PL协议，这样事务可以锁定正在访问的节点中的数据项。</li>
<li>INGRES的分布式版本使用去中心化的2PL以及中心化的死锁检测。</li>
<li>现在基本所有NewSQL都避开使用2PL，使用多版本时间戳排序。</li>
</ul>
<h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><ul>
<li>MVCC既确保事务之间的竞争，也允许long-running,read-only事务不会阻塞writers。</li>
<li>MemSQL,HyPer,HAHA,CockroachDB使用这个协议，他们对这个协议也各自做了工程上的优化和调整</li>
</ul>
<h4 id="2PL-amp-MVCC"><a href="#2PL-amp-MVCC" class="headerlink" title="2PL&amp;MVCC"></a>2PL&amp;MVCC</h4><ul>
<li>修改数据库的时候需要去获取锁，修改完一条记录，那么为该记录创建一个新版本，使只读查询可以避免请求锁，因此不会阻塞写事务。</li>
<li>MySQL’s InnoDB,Google’s Spanner,NuoDB（在MVCC基础上引用了gossip 协议在各节点之中广播版本信息）,Clustrix.</li>
<li>Spanner（及其后代F1和SpannerSQL）使用硬件设备（如GPS,原子时钟）来确保高精度时钟同步</li>
<li>CockroachDB使用混合时钟协议，结合松散 同步硬件时钟和逻辑计数器</li>
<li>所有的中间件和DBaaS服务都继承了它们底层DBMS架构使用的并发控制方案，因为大部分都使用MySQL作为底层DBMS，所以大部分的都是使用的2PL加上MVCC方案。</li>
</ul>
<h4 id="TO"><a href="#TO" class="headerlink" title="TO"></a>TO</h4><ul>
<li>VoltDB<ul>
<li>安排事务在每个分区中一次只执行一个</li>
<li>使用混合架构：去中心化方式安排单分区事务，中心化协调器对应多分区事务</li>
<li>通过逻辑时间戳对事务进行排序，然后调度它们以便在轮到它们时在分区上执行</li>
<li>不足：当事务横跨多个区时，由于网络的交互延迟导致节点等待message的时候空闲。</li>
</ul>
</li>
</ul>
<h2 id="二级索引（辅助索引）"><a href="#二级索引（辅助索引）" class="headerlink" title="二级索引（辅助索引）"></a>二级索引（辅助索引）</h2><ul>
<li><p>次级索引包含来自表的不同于其主键的属性集。它允许DBMS支持主键和分区键以外的快速查询。</p>
</li>
<li><p>分布式数据库中二级索引的challenge是他们不能总是像其他的数据库一样以相同的方式进行partition（如直接根据主键进行partition了）。</p>
</li>
<li>在分布式数据库中支持二级索引的两个设计思想：<ul>
<li>二级索引存在哪儿</li>
<li>如何在事务中维持二级索引</li>
</ul>
</li>
<li>中心化的协调器<ul>
<li>二级索引既在协调器节点，又在shard nodes。</li>
<li>优：整个系统中只有单个版本的index，维持起来很方便</li>
<li>劣：修改的时候需要修改所有节点上的副本。</li>
</ul>
</li>
<li>去中心化的协调器<ul>
<li>所有基于新架构的NewSQL都是去中心化的，且使用划分好的二级索引</li>
<li>每个节点都存储index的一部分。</li>
<li>优：修改的时候只需要修改一个节点</li>
<li>劣：查询的时候需要去横跨多个节点去找数据在哪儿</li>
</ul>
</li>
<li>Clustrix：既有replicated，粗粒度的(range-based)index在每个节点上，允许查询使用一个属性（并非partitioning属性找到合适的节点）；各个节点上又有第二partitioned index，能根据index找到该节点的tuples。但是都是ranges，而不是单个的值，减少了保持索引副本在集群中同步所需的调度次数。【没太理解】</li>
</ul>
<h2 id="复制-冗余"><a href="#复制-冗余" class="headerlink" title="复制(冗余)"></a>复制(冗余)</h2><h3 id="结点间数据一致性"><a href="#结点间数据一致性" class="headerlink" title="结点间数据一致性"></a>结点间数据一致性</h3><ul>
<li>强一致的事务，事务的写入必须必须在被确认提交（即持久化）之前被确认并安装到所有副本上。需要使用原子提交协议（2PC）<ul>
<li>优点：事务读起来方便，各个结点都满足一致性</li>
<li>缺点：开销也太大了吧，如果有一个节点失败了，或者网络分区延迟，系统就停着不动了。</li>
</ul>
</li>
</ul>
<h3 id="两种不同传播的执行模型"><a href="#两种不同传播的执行模型" class="headerlink" title="两种不同传播的执行模型"></a>两种不同传播的执行模型</h3><h4 id="active-active-复制"><a href="#active-active-复制" class="headerlink" title="active-active 复制"></a>active-active 复制</h4><ul>
<li>每个副本结点都同步执行相同的query</li>
</ul>
<h4 id="active-passive-复制"><a href="#active-passive-复制" class="headerlink" title="active-passive 复制"></a>active-passive 复制</h4><ul>
<li>先在单个结点处理请求，然后将DBMS所得状态传送到其他副本</li>
<li>大多数NewSQL DBMS都用这种方式，因为它们使用非确定性并发控制方案。（因为它们可能在不同副本上以不同的顺序执行，并且数据库的状态将在每个副本处出现分歧。因为执行顺序取决于很多因素，包括网络延迟，缓存停滞，时钟偏差等。）</li>
<li>确定性DBMS（例如，H-Store，VoltDB，ClearDB）不执行这些附加的协调步骤。因为它们保证事务的操作在每个副本上以相同的顺序执行，从而保证数据库的状态相同。</li>
</ul>
<h3 id="通过广域网WAN来进行复制"><a href="#通过广域网WAN来进行复制" class="headerlink" title="通过广域网WAN来进行复制"></a>通过广域网WAN来进行复制</h3><ul>
<li>因为会引起延迟，所以一般采用异步复制。</li>
<li>NewSQL系统中只有Spanner和CockroachDB能提供广域网上强一致副本的复制方案。Spanner使用了原子钟和GPS来做时间同步，而CockroachDB使用的是混合时钟方案。</li>
</ul>
<h2 id="恢复机制"><a href="#恢复机制" class="headerlink" title="恢复机制"></a>恢复机制</h2><ul>
<li><p>保证数据的更新不会丢失，最小化停机时间</p>
</li>
<li><p>操作：</p>
<ul>
<li>当主节点崩溃时，系统将会自动提升某个从节点充当新的主节点</li>
<li>而之前崩溃的主节点重新联机后，需要从新的主节点或者其他副本中更新自己的数据，弥补在停机这段时间内缺失的数据。</li>
</ul>
</li>
</ul>
<h3 id="两种方法恢复"><a href="#两种方法恢复" class="headerlink" title="两种方法恢复"></a>两种方法恢复</h3><ul>
<li>复的节点仍然从自身的存储中加载最后的检查点和写入日志，然后从其他节点读取缺失的日志部分。</li>
<li>节点重新联机时丢弃其检查点，让系统给它另一个新的检查点，然后从这个点开始恢复（系统中加入新的副本节点时也可以用同样的机制。）</li>
</ul>
<h1 id="未来趋势"><a href="#未来趋势" class="headerlink" title="未来趋势"></a>未来趋势</h1><h2 id="HTAP"><a href="#HTAP" class="headerlink" title="HTAP"></a>HTAP</h2><ul>
<li>分析新数据和历史数据的组合来进行知识推断，获得洞察力</li>
</ul>
<h3 id="三种方法"><a href="#三种方法" class="headerlink" title="三种方法"></a>三种方法</h3><h4 id="分别构建OLAT和OLTP数据库"><a href="#分别构建OLAT和OLTP数据库" class="headerlink" title="分别构建OLAT和OLTP数据库"></a>分别构建OLAT和OLTP数据库</h4><ul>
<li><p>前端的OLTP DBMS存储所有由事务创建的新数据，而在后端，系统使用ETL（extract-transform-load）工具将数据从OLTP DBMS导入到另一个后台的数据仓库DBMS</p>
</li>
<li><p>所有在OLAP系统中产生的新数据也将会被推送到OLTP库中。</p>
</li>
</ul>
<h4 id="Lambda架构"><a href="#Lambda架构" class="headerlink" title="Lambda架构"></a>Lambda架构</h4><ul>
<li>使用单独的批处理系统（例如，Hadoop，Spark）来计算历史数据视图，同时使用流处理系统（例如，Storm，Spark Streaming）来提供输入数据视图</li>
</ul>
<h4 id="HTAP数据库"><a href="#HTAP数据库" class="headerlink" title="HTAP数据库"></a>HTAP数据库</h4><ul>
<li><p>前两种方法的问题：</p>
<ul>
<li>数据传输时间开销大</li>
<li>部署和维护两种不同DBMS的管理开销巨大</li>
</ul>
</li>
<li><p>HTAP：结合了最近十年来在OLTP（例如，内存存储，无锁执行）和OLAP（例如，列式存储，矢量化执行 ）领域的技术积累，而且只需要一个DBMS。</p>
</li>
<li><p>HTAP例子：</p>
<ul>
<li>SAP HANA：在内部使用多个执行引擎，一个用于更适合事务的行数据，另一个用于更适合于分析的列数据。</li>
<li>MemSQL：使用两个不同的存储管理器（一个管理行，一个管理列），但是混合在同一个执行引擎中。</li>
</ul>
</li>
<li><p>OLTP转HTAP例子:</p>
<ul>
<li>HyPer将H-Store（OLTP）切换到MVCC的HTAP，可以支持更复杂的OLAP查询</li>
<li>VoltDB将OLTP性能转向提供流式语义【不清楚流式语义】</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>NewSQL系统的采用率相对较低，因为NewSQL DBMS的设计目标是支持事务性的工作负载，而这些应用大多数是企业应用（这些比较保守）</li>
<li>巨头们更愿意在自己的系统上进行改进和创新，而不是去收购初创的NewSQL公司。2014年Microsoft在SQLServer上新增了内存Hekaton引擎来增强OLTP处理能力。Oracle和IBM的创新进度比较慢，他们最近才为系统添加了列存储扩展，与新兴的OLAP DMBS（例如HP Vertica和Amazon Redshift）展开竞争，并有可能在未来推出内存中的OLTP工作负载处理系统。</li>
</ul>
<p><img src="/2020/08/28/NewSQL/image-20200827155826028.png" alt="image-20200827155826028"></p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/查询优化/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/查询优化/" itemprop="url">查询优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:13:07Z">
                2020-08-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>数据库系统实现第四章（查询执行）、第五章（查询编译器）笔记</p>
<h1 id="查询处理器"><a href="#查询处理器" class="headerlink" title="查询处理器"></a>查询处理器</h1><ul>
<li><p>查询处理器的主要部分</p>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200726201722939.png" alt="image-20200726201722939" style="zoom:67%;"></p>
</li>
<li><p>查询编译概貌</p>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200726201736827.png" alt="image-20200726201736827" style="zoom:67%;"></p>
</li>
<li><p>每个操作符的算法的选择是将逻辑查询计划转变为物理查询计划过程中的一个必不可少的部分。</p>
</li>
</ul>
<h1 id="查询执行"><a href="#查询执行" class="headerlink" title="查询执行"></a>查询执行</h1><h2 id="物理查询计划操作符介绍"><a href="#物理查询计划操作符介绍" class="headerlink" title="物理查询计划操作符介绍"></a>物理查询计划操作符介绍</h2><ul>
<li><p>扫描表：</p>
<ul>
<li>读一个关系R的所有元组，无论是表-扫描或是索引-扫描</li>
</ul>
</li>
<li><p>排序-扫描：</p>
<ul>
<li>若排序的属性a上有<strong>B树索引</strong>（B树索引是有序的吗？不是按照key值吗，key是属性a的值吗）或R是按a排序的索引顺序文件来存储的时候，可以直接对索引进行扫描即可得到所需排序的R。</li>
<li>若R很小，可以装进内存，那么可以使用表扫描或索引扫描得到元组，再使用主存排序算法</li>
<li>若R大，无法装进内存，通过多路归并得到排序好的R。</li>
</ul>
</li>
<li><p>物理操作符计算模型</p>
<ul>
<li>使用磁盘I/O数目作为操作符的“代价”</li>
</ul>
</li>
<li><p>衡量代价的参数</p>
<ul>
<li>关系R的所有元组所需的块的数目B(R)</li>
<li>关系R中的元组的数目 T(R)</li>
<li>关系的一个列中不同值的数目V(R,a)</li>
</ul>
</li>
<li><p>实现物理操作符的迭代器</p>
<ul>
<li>迭代器是三个方法的集合：Open(),GetNext(),Close()</li>
<li>使用迭代器时，同一时刻活跃的操作就有很多，元组只需要在操作符之间传递，无需将每个操作符得到的整个结果存放在磁盘或内存中。</li>
</ul>
</li>
</ul>
<h2 id="一趟算法"><a href="#一趟算法" class="headerlink" title="一趟算法"></a>一趟算法</h2><ul>
<li>至少一个操作对象能完全装入内存</li>
</ul>
<h3 id="一次单个元组操作的一趟算法"><a href="#一次单个元组操作的一趟算法" class="headerlink" title="一次单个元组操作的一趟算法"></a>一次单个元组操作的一趟算法</h3><ul>
<li>例子：选择和投影操作</li>
</ul>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200727164357896.png" alt="image-20200727164357896" style="zoom:67%;"></p>
<ul>
<li>因为输出缓冲区可能是其他操作的输入缓冲区，因此不把它算在所需空间内。</li>
<li>R如果一开始在磁盘上（可能从其他操作过来），那么代价就是执行一个表-扫描or索引-扫描所需代价。</li>
</ul>
<h3 id="整个关系的一元操作的一趟算法"><a href="#整个关系的一元操作的一趟算法" class="headerlink" title="整个关系的一元操作的一趟算法"></a>整个关系的一元操作的一趟算法</h3><ul>
<li>例子：分组操作符和去重操作符</li>
</ul>
<h4 id="消除重复"><a href="#消除重复" class="headerlink" title="消除重复"></a>消除重复</h4><ul>
<li><p>第一次看到该元组就将它复制到输出并且加入缓冲区中。</p>
</li>
<li><p>若缓冲区中存在该元组，就不必输出。为了加快判别，通常维护一个具有大量桶的散列表或者某种形式的平衡二叉查找树，可将散列表的存储开销忽视。</p>
</li>
<li><p>注：R中不重复的元组的block数要&lt;= M（内存缓冲区的块数）</p>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200727170533716.png" alt="image-20200727170533716" style="zoom:67%;"></p>
</li>
</ul>
<h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul>
<li>在主存中为分组属性的每一个值创建一个项，该项包括：分组属性的值和每个聚集的一个或多个累计值。<ul>
<li>Min(),Max()函数，保持最小值或最大值即可。</li>
<li>Count(),为组中见到的每个元组加1</li>
<li>SUM(),增加非NULL属性a的值</li>
<li>AVG(),总和&amp;个数</li>
</ul>
</li>
<li>直到扫描最后一个元组后，才开始为分组操作创建输出，故这种算法不适合迭代器结构，因为要求在Open方法的时候必须将全部分组做好（不实际）</li>
<li>同样用一个内存数据结构在已知分组属性值找到分组的项（散列表&amp;各分组的项）</li>
<li>一般，关系R都没有聚簇，故读取R的全部元组需要进行T(R)次I/O</li>
</ul>
<h3 id="二元操作的一趟算法"><a href="#二元操作的一趟算法" class="headerlink" title="二元操作的一趟算法"></a>二元操作的一趟算法</h3><ul>
<li><p>例子：除了上方的操作之外的都可以归为这一类，如并、交、差、连接和积的集合形式以及包形式</p>
</li>
<li><p>以下假定,<strong>R是两个关系中较大的一个</strong>，将D放在内存中。</p>
</li>
<li>集合与包的区别：集合操作自动消除重复，包操作是不消除重复的</li>
</ul>
<h4 id="集合并"><a href="#集合并" class="headerlink" title="集合并"></a>集合并</h4><ul>
<li>将S读到内存的M-1个缓冲区中建立一个查找结构，查找关键字是整个元组，现将S的元组都复制到输出。然后一次一块将R的每一块读到第M个缓冲区中，对于R的每一个元组t，观察t是否在S中，若不在，也将t复制到输出。</li>
</ul>
<h4 id="集合交"><a href="#集合交" class="headerlink" title="集合交"></a>集合交</h4><ul>
<li>跟并类似，但t若在S中，复制到输出。</li>
</ul>
<h4 id="集合差"><a href="#集合差" class="headerlink" title="集合差"></a>集合差</h4><ul>
<li>R-S：检查R中每一个元组t，若t不在S中，将t复制到输出。</li>
<li>S-R：检查R中每一个元组t，若t在S中，从主存中S的副本中删掉t，考虑完R的每一个元组后，将S中剩余的那些元组复制到输出。</li>
</ul>
<h4 id="包交"><a href="#包交" class="headerlink" title="包交"></a>包交</h4><ul>
<li>将S中每一个不同的元组与<strong>一个计数</strong>联系起来，其初值是该元组在S中出现的次数。读出R的每一块，对于R的每一个元组t，观察t是否在S中出现，若出现，且与t对应的计数为正值，<strong>那么输出t并将计数减1</strong>.</li>
</ul>
<h4 id="包差"><a href="#包差" class="headerlink" title="包差"></a>包差</h4><ul>
<li>S-R：依次读取R的每个元组，若t在S中出现，则将与之对应的计数递减1，最后将内存中计数时正数的每一个元组复制到输出，复制的次数等于其计数。</li>
<li>R-S：依次读取R的元组t，若t不在S中出现，则将t复制到输出，若t在S中出现，查看t对应的计数c的当前值，若c=0，则将t复制到输出，若c&gt;0，则不将t复制到输出，但将c值减1。</li>
</ul>
<h4 id="积"><a href="#积" class="headerlink" title="积"></a>积</h4><ul>
<li>读取R中的每一块，对R中每一个元组t与主存S(M-1个缓冲区)中的每一个元组连接，形成后即将其输出。输出所占空间很大，且处理R的每一个元组所耗的时间很长。</li>
</ul>
<h4 id="自然连接"><a href="#自然连接" class="headerlink" title="自然连接"></a>自然连接</h4><ul>
<li>将R(X,Y)与S(Y,Z)连接。<ul>
<li>读取S的所有元组，构造一个以Y的属性为查找关键字的内存查找结构（M-1个缓冲块中）。</li>
<li>将R的每一块读到第M个缓冲块中，对于R的元组t，利用查找结构找到S中与t在Y的所有属性上相符合的元组与t进行连接后形成一个元组输出。</li>
</ul>
</li>
</ul>
<h2 id="嵌套循环连接"><a href="#嵌套循环连接" class="headerlink" title="嵌套循环连接"></a>嵌套循环连接</h2><ul>
<li><p>R（X,Y）与S(Y,Z)连接，R在内循环，S在外循环，假定B(S)&lt;=B(R)[外层循环中使用较小的关系略有优势]</p>
</li>
<li><p>没有必要要求有一个关系必须能装入内存</p>
</li>
<li><p>基于元组的嵌套循环连接：</p>
</li>
<li><p>改进：在R的连接属性（Y)上建立索引，便于查找元组。</p>
</li>
<li><p>基于元组的嵌套循环连接的迭代器</p>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200728213534782.png" alt="image-20200728213534782"></p>
</li>
<li><p>基于块的嵌套循环连接算法</p>
<ul>
<li>S作为外层循环，可能B(S)&gt;=M,那么需要将S分多次迭代。</li>
<li>R作为内层循环，每次读入一个块，依次将块中元组和缓冲区的S元组做连接，输出结果。</li>
</ul>
</li>
<li><p>嵌套循环连接的分析：</p>
<ul>
<li>代价与两个关系的大小(blocks数)的乘积再除以M得到的商成比例</li>
</ul>
</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/2020/08/05/查询优化/查询优化\image-20200728214802020.png" alt="image-20200728214802020" style="zoom:67%;"></p>
<h2 id="基于排序的两趟算法"><a href="#基于排序的两趟算法" class="headerlink" title="基于排序的两趟算法"></a>基于排序的两趟算法</h2><ul>
<li>数据先被读到内存处理了一下之后再写回磁盘，然后重新读取磁盘完成操作。</li>
<li>以下假定B(R)&gt;M,将R分成大小为M的chunk并排序。</li>
</ul>
<h3 id="两阶段多路归并排序（2PMMS）"><a href="#两阶段多路归并排序（2PMMS）" class="headerlink" title="两阶段多路归并排序（2PMMS）"></a>两阶段多路归并排序（2PMMS）</h3><ul>
<li><p>有一个子表的概念，子表不能超过M-1个（缓冲区数为M个），假定R占用B个块，因为每个子表可以包括M个块，于是子表数目为B/M,要求B/M &lt;= M-1。</p>
</li>
<li><p>阶段1：将R中的元组放入M个缓冲区中，利用主存排序进行排序，将排序得到的子表存到外存外【保证每个子表（最多M个）是有序的】</p>
</li>
<li><p>阶段2：将排好序的子表进行归并（选择每个子表最前面的块读入M-1个缓冲使用归并进行排序）</p>
<p><img src="/2020/08/05/查询优化/查询优化\image-20200728220718306.png" alt="image-20200728220718306" style="zoom:67%;"></p>
</li>
</ul>
<h3 id="利用排序去除重复"><a href="#利用排序去除重复" class="headerlink" title="利用排序去除重复"></a>利用排序去除重复</h3><ul>
<li>与2PMMS的阶段1一样，就是在阶段2时，不断复制<strong>每一块的第一个</strong>未考虑的元组t到输出并忽略与它相同的所有元组，即将输入快中所有的t删除。</li>
</ul>
<h3 id="利用排序进行分组和聚集"><a href="#利用排序进行分组和聚集" class="headerlink" title="利用排序进行分组和聚集"></a>利用排序进行分组和聚集</h3><ul>
<li>与2PMMS相似</li>
<li>阶段1：用分组属性作为排序关键字，对每M块排序</li>
<li>阶段2：查找分组属性的最小值，将该最小值v成为下一分组，然后为这个组计算出聚集值即可。</li>
</ul>
<h3 id="基于排序的并算法"><a href="#基于排序的并算法" class="headerlink" title="基于排序的并算法"></a>基于排序的并算法</h3><ul>
<li>与2PMMS相似</li>
<li>阶段1：创建R与S的排序子表</li>
<li>阶段2：为R和S的每个子表使用一个内存缓冲区，在缓冲区中找元组t，复制到输出，并且从缓冲区中删除t的所有副本。</li>
</ul>
<h3 id="基于排序的交和差算法"><a href="#基于排序的交和差算法" class="headerlink" title="基于排序的交和差算法"></a>基于排序的交和差算法</h3><ul>
<li>除了t的副本什么情况下复制到输出缓冲区有所区别之外，其他都一样。</li>
</ul>
<h3 id="基于排序的一个简单的连接算法"><a href="#基于排序的一个简单的连接算法" class="headerlink" title="基于排序的一个简单的连接算法"></a>基于排序的一个简单的连接算法</h3><ul>
<li>先将R和S都使用2PMMS根据连接值进行排序（假定只有一个连接键）</li>
<li><p>阶段1：R和S个占一块缓冲区，剩下的M-2都用来装连接值为y的所有元组</p>
</li>
<li><p>代价：5(B(R)+B(S))次磁盘I/O，B(R)&lt;=M^2且B(S)&lt;=M^2，用于连接的属性具有公共的值的所有元组必须能全部装入M个缓冲区中。</p>
</li>
</ul>
<h3 id="一个更有效的基于排序的连接"><a href="#一个更有效的基于排序的连接" class="headerlink" title="一个更有效的基于排序的连接"></a>一个更有效的基于排序的连接</h3><ul>
<li>当连接属性具有公共的值元组不多的时候，可以将排序的第二阶段和连接本身合并。</li>
<li>区别：为R和S创建大小为M的排序的子表</li>
</ul>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2020/08/05/查询优化/查询优化\image-20200731225846330.png" alt="image-20200731225846330" style="zoom:67%;"></p>
<h2 id="基于散列的两趟算法"><a href="#基于散列的两趟算法" class="headerlink" title="基于散列的两趟算法"></a>基于散列的两趟算法</h2><ul>
<li>M个缓冲区，将关系R分到M-1个桶中，每一个桶和一个缓冲区联系起来，当一个缓冲区满了，就将它写到磁盘并且初始化另一个块。</li>
<li>上致跟上面都差不多..</li>
</ul>
<h2 id="缓冲区管理"><a href="#缓冲区管理" class="headerlink" title="缓冲区管理"></a>缓冲区管理</h2><ul>
<li>之前的操作都假定可以获得数量M的内存缓冲区，但实际上缓冲区很少预先分配给操作符，是由缓冲区管理器来进行统一分配的。</li>
</ul>
<h3 id="缓冲区管理结构"><a href="#缓冲区管理结构" class="headerlink" title="缓冲区管理结构"></a>缓冲区管理结构</h3><ul>
<li>有两个主要的缓冲区管理结构<ul>
<li>缓冲区直接控制内存（缓冲区只有内存部分）</li>
<li>缓冲区在虚拟内存中分配空间（一部分缓冲区还在磁盘上，但是我们不关心），这情况下换进换出多了，会抖动。</li>
</ul>
</li>
<li>一般，DBMS初始化时，都会先设缓冲区的数目（作为一个参数）。</li>
</ul>
<h3 id="缓冲区管理策略"><a href="#缓冲区管理策略" class="headerlink" title="缓冲区管理策略"></a>缓冲区管理策略</h3><ul>
<li>跟操作系统中的调度策略一样…</li>
<li>查询处理的内存管理：<ul>
<li>在某些DBMS中，内存是在多个缓冲池中（具有不同目的），有些是用来存放磁盘页面，有些是用来存放散列表。</li>
</ul>
</li>
<li>最近最少使用（LRU)<ul>
<li>缓冲区管理器保持每个块最后一次时间访问的表</li>
</ul>
</li>
<li>先进先出(FIFO)</li>
<li>“时钟”算法（第二次机会）</li>
<li>系统控制<ul>
<li>针对“被钉住的”块（有其他指向它的块），缓冲区管理器都不能驱除它。</li>
</ul>
</li>
<li>这节没怎么仔细看..</li>
</ul>
<h2 id="使用超过两趟的算法"><a href="#使用超过两趟的算法" class="headerlink" title="使用超过两趟的算法"></a>使用超过两趟的算法</h2><ul>
<li>这节没看..</li>
</ul>
<h1 id="查询编译器"><a href="#查询编译器" class="headerlink" title="查询编译器"></a>查询编译器</h1>
          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/基础与索引/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/基础与索引/" itemprop="url">基础与索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:12:50Z">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据库系统实现/" itemprop="url" rel="index">
                    <span itemprop="name">数据库系统实现</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>包括数据库系统实现第一章、第二章、第三章（索引）</li>
</ul>
<h1 id="数据库管理系统成分"><a href="#数据库管理系统成分" class="headerlink" title="数据库管理系统成分"></a>数据库管理系统成分</h1><p><img src="/2020/08/05/基础与索引/image-20200724142035493.png" alt="image-20200724142035493"></p>
<ul>
<li>分为两大块主要模块：查询响应和事务处理</li>
</ul>
<h2 id="查询响应"><a href="#查询响应" class="headerlink" title="查询响应"></a>查询响应</h2><ul>
<li>先由查询编译器对查询进行分析和优化（如检查语义和语法是否正确、构建语法分析树），选择物理逻辑计划</li>
<li>得到查询计划后，传给执行引擎</li>
<li>执行引擎向资源管理器请求记录or关系的元组</li>
<li>资源管理器掌握着存放关系的数据文件、文件中的数据格式和记录大小，以及支持对于数据文件中的元素进行快速查找的索引文件。查找数据的请求被传送给缓冲区管理器</li>
<li>缓冲区管理器与磁盘交互（以磁盘块 单位）</li>
</ul>
<h2 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h2><ul>
<li>分为两个主要部分</li>
</ul>
<h3 id="并发控制管理器"><a href="#并发控制管理器" class="headerlink" title="并发控制管理器"></a>并发控制管理器</h3><ul>
<li>负责保证事务的原子性和孤立性</li>
</ul>
<h3 id="日志和恢复管理器"><a href="#日志和恢复管理器" class="headerlink" title="日志和恢复管理器"></a>日志和恢复管理器</h3><ul>
<li>负责事务的持久性</li>
</ul>
<h1 id="辅助存储管理"><a href="#辅助存储管理" class="headerlink" title="辅助存储管理"></a>辅助存储管理</h1><h2 id="存储器层次"><a href="#存储器层次" class="headerlink" title="存储器层次"></a>存储器层次</h2><p><img src="/2020/08/05/基础与索引/image-20200724143448491.png" alt="image-20200724143448491"></p>
<h2 id="组织磁盘上的数据"><a href="#组织磁盘上的数据" class="headerlink" title="组织磁盘上的数据"></a>组织磁盘上的数据</h2><ul>
<li>一般，一个磁盘块中仅存放<strong>一个关系的元素</strong></li>
</ul>
<h3 id="定长记录"><a href="#定长记录" class="headerlink" title="定长记录"></a>定长记录</h3><ul>
<li>下图假定所有字段必须以一个4的倍数的字节开始</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724150344115.png" alt="image-20200724150344115"></p>
<p><img src="/2020/08/05/基础与索引/image-20200724150409109.png" alt="image-20200724150409109"></p>
<ul>
<li>当存取或修改记录时，记录（与整个块一起）就被移进主存</li>
<li>块首部包含：<ul>
<li>与一个或多个其他块的链接</li>
<li>关于这个块在这样一个网络中所扮演的角色的信息</li>
<li>关于这个块的元组属于哪个关系的信息</li>
<li>一个给出每一条记录在块内偏移量的“目录”</li>
<li>指明块最后一次修改和/或存取时间的时间戳</li>
</ul>
</li>
<li>记录长度为316字节，假定4096字节的块，会有292字节的浪费</li>
</ul>
<h2 id="块和记录地址的表示"><a href="#块和记录地址的表示" class="headerlink" title="块和记录地址的表示"></a>块和记录地址的表示</h2><ul>
<li>内存中：与虚拟内存地址相关</li>
<li>二级存储器中：与磁盘的设备ID，柱面号等等相关</li>
</ul>
<h3 id="客户机-服务器系统中的地址"><a href="#客户机-服务器系统中的地址" class="headerlink" title="客户机-服务器系统中的地址"></a>客户机-服务器系统中的地址</h3><ul>
<li>服务器：为客户端进程提供二级存储器数据，数据处于数据库地址空间，表示地址的方法有：<ul>
<li>物理地址（字符串）：<ul>
<li>存储所连接的主机</li>
<li>块所在的磁盘或其它设备的标识符</li>
<li>柱面号</li>
<li>磁道号</li>
<li>块号</li>
<li>块内偏移量</li>
</ul>
</li>
<li>逻辑地址</li>
</ul>
</li>
<li>客户端：其地址空间看作主存本身</li>
</ul>
<h2 id="指针混写"><a href="#指针混写" class="headerlink" title="指针混写"></a>指针混写</h2><ul>
<li>把块从二级存储器移到主存储器中，块内指针可以“混写”，即从数据库地址空间转换为虚拟地址空间</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724153804351.png" alt="image-20200724153804351"></p>
<h3 id="被钉住的记录和块"><a href="#被钉住的记录和块" class="headerlink" title="被钉住的记录和块"></a>被钉住的记录和块</h3><ul>
<li>即内存中一个块当前不能安全地被写回磁盘</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724154305211.png" alt="image-20200724154305211"></p>
<h2 id="变长数据和记录"><a href="#变长数据和记录" class="headerlink" title="变长数据和记录"></a>变长数据和记录</h2><h3 id="变长字段的记录"><a href="#变长字段的记录" class="headerlink" title="变长字段的记录"></a>变长字段的记录</h3><ul>
<li>当address地址为NULL时，直接在指向的指针空间处放一个空指针，进一步减少空间。</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724154657714.png" alt="image-20200724154657714"></p>
<h3 id="具有重复字段的记录"><a href="#具有重复字段的记录" class="headerlink" title="具有重复字段的记录"></a>具有重复字段的记录</h3><ul>
<li>法一：</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155032593.png" alt="image-20200724155032593"></p>
<ul>
<li>法二：<ul>
<li>保证记录定长，有效对记录进行搜索，但增加 磁盘I/O数目</li>
</ul>
</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155045741.png" alt="image-20200724155045741"></p>
<ul>
<li><h3 id="不能装入一个块中的记录"><a href="#不能装入一个块中的记录" class="headerlink" title="不能装入一个块中的记录"></a>不能装入一个块中的记录</h3></li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724155711393.png" alt="image-20200724155711393"></p>
<ul>
<li>BOLB(二进制大对象)</li>
</ul>
<h3 id="列存储"><a href="#列存储" class="headerlink" title="列存储"></a>列存储</h3><ul>
<li>适用于：大多数查询请求是<strong>针对所有数据</strong>或者<strong>列的大部分数据</strong>。（常用于“分析型”查询）</li>
<li>可以与值一起保存元组ID号~</li>
</ul>
<h2 id="记录的修改"><a href="#记录的修改" class="headerlink" title="记录的修改"></a>记录的修改</h2><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><ul>
<li>元组以某个固定次序存储（如按主键顺序存储）</li>
<li>插入的两种方法：（使用偏移量加速找到插入的位置）<img src="/2020/08/05/基础与索引/image-20200724162909062.png" alt="image-20200724162909062"><ul>
<li>在“邻近块”中找空间</li>
<li>创建一个溢出块</li>
</ul>
</li>
</ul>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><ul>
<li><p>在记录处放删除标志</p>
<ul>
<li>可以是偏移量表中的空指针</li>
<li>可以用删除标记代替记录,只用到第一个字节，后续的字节可用于另一个记录~</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200724164311442.png" alt="image-20200724164311442"></p>
</li>
</ul>
<p>### </p>
<h1 id="索引结构"><a href="#索引结构" class="headerlink" title="索引结构"></a>索引结构</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><ul>
<li><p><strong>主索引&amp;辅助索引</strong>：主索引（主键）能确定记录在数据文件中的位置，而辅助索引不能</p>
</li>
<li><p>索引类型：顺序文件（稠密索引、稀疏索引）、B树索引、散列表索引。</p>
</li>
<li><p>稠密索引：为数据文件中的每条记录设一个键-指针对。其中所索引快保持键的顺序与文件中的排序顺序一致。（记录时排好序的）</p>
</li>
<li><p>稀疏索引：为数据文件中的每个存储块设一个键-指针对。（假定数据文件排好序）【只会是主索引】</p>
</li>
<li><p>多级索引：索引文件占据多个存储块，可采用多级索引【主索引】</p>
</li>
<li><p>辅助索引：总是稠密索引，因为不是主键索引（如果该column也不是unique的)，那就存在多个相同的索引内容，索引数据跨越多个块。<strong>使用辅助索引比使用主索引可能需要多得多的磁盘I/O，但无法解决！</strong></p>
<ul>
<li>避免键值重复：使用桶的间接层</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200725220045067.png" alt="image-20200725220045067"></p>
<p><img src="/2020/08/05/基础与索引/image-20200726143152340.png" alt="image-20200726143152340"></p>
</li>
<li><p>辅助索引的运用：</p>
<ul>
<li><p>被组织成顺序文件的关系（如上都是）</p>
</li>
<li><p>作为“堆”结构的主键索引（不太能理解）</p>
</li>
<li><p>聚集文件</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Movie(title,year,length,genre,studioName,producerC<span class="comment">#)</span></span><br><span class="line">Studio(name,address,presC<span class="comment">#)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">Select</span> title,<span class="keyword">year</span></span><br><span class="line"><span class="keyword">From</span> Movie,Studio</span><br><span class="line"><span class="keyword">WHERE</span> presC<span class="comment"># = zzz AND Movie.studioName = Studio.name;(假定这是该应用场景典型的查询)</span></span><br><span class="line"></span><br><span class="line">为这个两个关系建立一个聚集文件结构，在查询键presC<span class="comment">#上建立索引。</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/08/05/基础与索引/image-20200725221051780.png" alt="image-20200725221051780"></p>
</li>
</ul>
</li>
</ul>
<h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><ul>
<li>B-树根结点块是永久地缓冲在主存中的绝佳选择。</li>
</ul>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul>
<li><p>插入时，若没有位置，就存储到该块链上的某个溢出块中。</p>
</li>
<li><p>删除时，若块中前一条记录被删除，就一条记录需移动到前面。</p>
<p><img src="/2020/08/05/基础与索引/image-20200726151506740.png" alt="image-20200726151506740"></p>
</li>
</ul>
<h3 id="可扩展散列表"><a href="#可扩展散列表" class="headerlink" title="可扩展散列表"></a>可扩展散列表</h3><ul>
<li><p>动态散列表之一</p>
</li>
<li><p>引入间接层，用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶。</p>
</li>
<li><p>指针数组能增长，长度总是2的幂。</p>
<p><img src="/2020/08/05/基础与索引/image-20200726152253294.png" alt="image-20200726152253294"></p>
</li>
<li><p>通过判断i和j（右上角小块中的）的大小，不断加倍桶数组，且分裂数据块。</p>
</li>
<li><p>优点：若桶数组小到可以存放在内存中，那么访问桶数组就不需要进行磁盘I/O。</p>
</li>
</ul>
<h3 id="线性散列表"><a href="#线性散列表" class="headerlink" title="线性散列表"></a>线性散列表</h3><p><img src="/2020/08/05/基础与索引/image-20200726153509875.png" alt="image-20200726153509875"></p>
<ul>
<li>i(当前被使用的散列函数值的位数)、n（当前的桶数）、r（当前散列表中的记录总数）</li>
<li>（没怎么看懂）</li>
<li>优点：桶的增长较为缓慢</li>
</ul>
<h2 id="多维索引"><a href="#多维索引" class="headerlink" title="多维索引"></a>多维索引</h2><ul>
<li>数据结构：类散列表方法，类树方法</li>
</ul>
<h4 id="多维数据的散列结构"><a href="#多维数据的散列结构" class="headerlink" title="多维数据的散列结构"></a>多维数据的散列结构</h4><ul>
<li>网格文件：通过排序该维的值来划分该维</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200726161359875.png" alt="image-20200726161359875"></p>
<ul>
<li><p>当数据分布性很好，且数据文件本身又不太大，那么可以选择网格线。</p>
</li>
<li><p>分段散列：为每个二进制位设定一个属性</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162116830.png" alt="image-20200726162116830" style="zoom:50%;"></p>
<ul>
<li>对最近邻查询或范围查询实际上没有什么用，因为点之间的物理距离并没有通过桶号的接近反映出来。</li>
<li>如果只需要支持部分匹配查询，只需要指定某属性的值而不指定其他属性，那么分段散列函数可能会比网格文件好。</li>
</ul>
</li>
</ul>
<h4 id="多维数据的树结构"><a href="#多维数据的树结构" class="headerlink" title="多维数据的树结构"></a>多维数据的树结构</h4><ul>
<li><p>多键索引</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162746159.png" alt="image-20200726162746159" style="zoom:50%;"></p>
</li>
<li><p>kd-树</p>
<p><img src="/2020/08/05/基础与索引/image-20200726162909353.png" alt="image-20200726162909353" style="zoom:50%;"></p>
</li>
<li><p>四叉树：根据象限来划分</p>
<p><img src="/2020/08/05/基础与索引/image-20200726163747603.png" alt="image-20200726163747603" style="zoom:50%;"></p>
</li>
<li><p>R-树（内部结点对应于某个内部区域）</p>
<ul>
<li>对于”where-am-I”这类典型查询，R树是有用的。</li>
</ul>
<p><img src="/2020/08/05/基础与索引/image-20200726164316027.png" alt="image-20200726164316027" style="zoom:33%;"></p>
</li>
</ul>
<h2 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h2><ul>
<li>每条记录作为二进制位，针对年龄这个字段，如18岁，假定有6条记录可能在第1,2,3条记录的年龄为18岁，则位图表示为111000</li>
<li>压缩位图：采用分段长度编码</li>
</ul>
<p>注： 一般做删除操作，都直接在数据文件中采用“删除标记”</p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/08/05/skywalking适配mysql/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/05/skywalking适配mysql/" itemprop="url">skywalking适配mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-05T15:10:23Z">
                2020-08-05
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/skywalking/" itemprop="url" rel="index">
                    <span itemprop="name">skywalking</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><ul>
<li><p>为了去抓取应用端发来的负载信息，比如sql,timestamp,sql中的para,和select语句的result集合，通过分析这些负载，来模拟负载，主要用于抓取应用端的负载，相当于数据挖掘中获取数据的来源把~~</p>
</li>
<li><p>这篇主要是总结我在适配skywalking获取mysql应用端的负载遇到的问题和感受。</p>
</li>
</ul>
<h1 id="先行"><a href="#先行" class="headerlink" title="先行"></a>先行</h1><ul>
<li><p>利用skywalking在以mysql为数据库的应用程序中抓取负载，在实验中，以oltpbench为应用端。大致的配置是，在<a href="https://github.com/apache/skywalking拉去skywalking源代码，利用说明文档进行编译" target="_blank" rel="noopener">https://github.com/apache/skywalking拉去skywalking源代码，利用说明文档进行编译</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/apache/skywalking.git</span><br><span class="line">cd skywalking/</span><br><span class="line">git submodule init</span><br><span class="line">git submodule update</span><br><span class="line">./mvnw clean package -DskipTests</span><br></pre></td></tr></table></figure>
</li>
<li><p>编译好的在dist目录下，如果没有别的需求，可直接在启动应用端的脚本或命令行中加入-javaagent /skywalking/agent/skywalking-agent.jar。</p>
</li>
<li>由于项目中需要按照一定的形式将抓取到的日志输入固定的文件中，因此主要对skywalking的三个包进行修改，分别是mysql-common,mysql-5.x,jdbc-commons，这三个都在./apm-sniffer/apm-sdk-plugins中。</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="mysql-commons"><a href="#mysql-commons" class="headerlink" title="mysql-commons"></a>mysql-commons</h2><ul>
<li>里面都是一些截流器，有针对预编译sql的PreparadStatementExeucute，还有PreparadStatementBatchExeucute，和普通的StateExecute。这些截流器都被注册了，与mysql-5.x中的注册器对应，注册器指明mysql中哪里函数利用那些截流器去捕获。如”add batch”函数就利用PreparadStatementBatchExeucute去抓取。”executeUpdate”利用PreparadStatementExeucute和StateExecute去抓取（根据不同的sql类型）</li>
</ul>
<h2 id="mysql-5-x"><a href="#mysql-5-x" class="headerlink" title="mysql-5.x"></a>mysql-5.x</h2><ul>
<li>一些注册器，与拦截器对应即可</li>
</ul>
<h2 id="jdbc-commons"><a href="#jdbc-commons" class="headerlink" title="jdbc-commons"></a>jdbc-commons</h2><ul>
<li>主要是加了connId，还有与commit,rollback有关的拦截器，在这个包中，也进行了修改。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><h2 id="mysql-的-jdbc重复调用问题"><a href="#mysql-的-jdbc重复调用问题" class="headerlink" title="mysql 的 jdbc重复调用问题"></a>mysql 的 jdbc重复调用问题</h2><ul>
<li><p>查看Mysql的jdbc的包（可利用反编译软件进行查看），发现add batch又调用了executeUpdate函数，导致skywalking抓包的时候重复捕获一条语句，导致重复。此外，还有executeUpdate自调用三次，导致一条日志被打印出三次。这类问题的处理方式，利用查看调用栈，分析它的调用过程，来忽略一些日志的输出。</p>
</li>
<li><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Exception ex = <span class="keyword">new</span> Exception();</span><br><span class="line">StackTraceElement[] ste = ex.getStackTrace();</span><br><span class="line"><span class="keyword">boolean</span> fromExecuteBatch = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ste.length; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(ste[i].getMethodName().contains(<span class="string">"executeBatch"</span>)||ste[i].getMethodName().contains(<span class="string">"executeUpdate$Original"</span>))&#123;</span><br><span class="line">        fromExecuteBatch = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="mysql中以一个host为一个connId"><a href="#mysql中以一个host为一个connId" class="headerlink" title="mysql中以一个host为一个connId"></a>mysql中以一个host为一个connId</h2><ul>
<li>由于项目的需要，我们需要得到connId，在jdbc-commons的相应位置加上与connId相关的代码。</li>
<li>但是发现createstatement有个问题，就是无论多少个线程，以及无论多少个连接，但输出总是一个相同的。但从mysql端捕获到的connectionInfo都是不同的，后来发现是skywalking中是根据host和Port来存储connectionInfo的，若从相同的host和port发送数据库请求，那skywalking（mysql部分，oracle应该不是这样的)就认为是用一条connectionInfo信息，导致出错。</li>
<li>这个问题的解决方法：就不用host和port进行存储..换了另一种方式。</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>skywalking适配mysql耗时达1周左右，发现自己还是畏惧源码的阅读，无论是skywalking还是mysql-jdbc还是不能有效的进行阅读，希望下次能改进。</li>
<li>自己对于问题的解决不能深入，抱着懒散的心态~，要加油呀！</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/" itemprop="url">SQLCheck: Automated Detection and Diagnosis of SQL Anti-Patterns</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-20T13:50:50Z">
                2020-07-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/论文/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation"></a>Motivation</h1><ul>
<li>数据库即服务（DBaaS)目前很流行，云计算的出现，让很多开发人员都直接使用云上数据库而不用自己去搭建一个数据库，这扩展了数据库的使用，但很多开发人员没有数据库相关知识，可能写出来的sql语句存在APs（Anti-Patterns)，而APs会影响访问数据库时的性能，进而对应用产生影响。因此，这篇文章站在这个角度，去检测sql语句是否存在APs，并且将sql中存在的APs进行排序（这里主要是为了修复主要影响性能的APs，因为修复APs可能修改数据库schema等等，会对其他的sql产生一定影响），最后对主要的APs进行自动修复（实质上这篇文章是按照现有的规则进行修复）。</li>
</ul>
<h1 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge"></a>Challenge</h1><ul>
<li>AP可能违反基本数据库设计原则（如，参照一致性等等）</li>
</ul>
<h1 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h1><ul>
<li><p>讲述了如今其他识别APs的工具的局限性</p>
</li>
<li><p>注意：detection是有按照一定的rule进行匹配来将AP侦测出来</p>
</li>
<li><p>Detection：将query和data分析相结合进行AP侦测。</p>
</li>
<li><p>Rank：针对APs上的<strong>性能数据进行建模</strong>，获取rank model。</p>
</li>
<li><p>Fix：基于规则query重构技术提出fix APs的建议。</p>
</li>
</ul>
<h1 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h1><h2 id="Classification-of-Anti-Patterns"><a href="#Classification-of-Anti-Patterns" class="headerlink" title="Classification of Anti-Patterns"></a><strong>Classification of Anti-Patterns</strong></h2><p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717144713076.png" alt="image-20200717144713076"></p>
<h2 id="Impact-of-Anti-Patterns"><a href="#Impact-of-Anti-Patterns" class="headerlink" title="Impact of Anti-Patterns"></a><strong>Impact of Anti-Patterns</strong></h2><ul>
<li><strong>Performance</strong>：性能，如吞吐和延迟</li>
<li><strong>Maintainability:</strong>当业务发生了改变，应用设计和组件被修改的容易程度（这里指sql和schema）</li>
<li><strong>Accuracy:</strong>存进去的数据和读出来的时候是否还是一致的（如，浮点数的精度是否丢失了，考虑数据库schema的column类型定义的如何）</li>
</ul>
<h1 id="System-Overview"><a href="#System-Overview" class="headerlink" title="System Overview"></a>System Overview</h1><p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717175237267.png" alt="image-20200717175237267"></p>
<ul>
<li>ap-detect:静态分析queries，分析数据库中的数据和元数据</li>
<li>ap-rank：根据detect出来的AP对各类评价指标的影响排序（文中设置user-study,由于可以根据自己的应用需求调整不同评价指标的权重，如读事务多的应用场景对读性能更为看重）</li>
<li>ap-fix：根据定义好的rule来对AP进行fix（也就是说rule是有限的，无法cover到全部，<strong>这里detect从后面的实验来看也应该是有限的AP，就是定义的AP越多识别出来的也越多…</strong>）</li>
</ul>
<h1 id="Finding-Anti-Patterns"><a href="#Finding-Anti-Patterns" class="headerlink" title="Finding Anti-Patterns"></a>Finding Anti-Patterns</h1><ul>
<li>Query-Analyser：获取query的column name、table names、predicates、constraints和indexes等等（就是一些logical feature)</li>
<li>Data-Analyser：获取数据库中表的每个Column的数据分布和format（类型？）等</li>
<li>Query-Rules：根据建立好的rules识别APs判别query是否存在APs</li>
<li>Data-Rules：根据建立好的rules识别APs判别data是否存在APs</li>
</ul>
<p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200717180220192.png" alt="image-20200717180220192"></p>
<h2 id="Query-Analysis"><a href="#Query-Analysis" class="headerlink" title="Query Analysis"></a><strong>Query Analysis</strong></h2><ul>
<li><strong>intra-query detection：</strong>从单条sql获取context，使用预定好的rule（rule里由一系列函数组成）去detect，使用<strong>no-validating parsing logic</strong>来支持不同数据库的查询，返回<strong>annotating the parse tree</strong>(ap-detect和ap-fix使用这个去找到APS)</li>
<li>inter-query detection：从sql和sql之间获取context，利用整个应用的context，不一定是相邻的,在 Intra-query上多包涵了两个组件：<strong>schama和与应用相关的queries</strong></li>
</ul>
<h2 id="Data-Analysis"><a href="#Data-Analysis" class="headerlink" title="Data Analysis"></a>Data Analysis</h2><ul>
<li>首先scan<strong>数据库</strong>收集【收集代价大，定期执行】：<ul>
<li>tables的schemata</li>
<li>数据在相关column上的分布（<em>e.g.</em>, unique values,mean, median等等）</li>
</ul>
</li>
<li>还是根据相应的规则去check构建好的context中是否存在APs</li>
</ul>
<h1 id="Ranking-Anti-Patterns"><a href="#Ranking-Anti-Patterns" class="headerlink" title="Ranking Anti-Patterns"></a>Ranking Anti-Patterns</h1><h2 id="Metrics-for-Ranking-Anti-Patterns"><a href="#Metrics-for-Ranking-Anti-Patterns" class="headerlink" title="Metrics for Ranking Anti-Patterns"></a>Metrics for Ranking Anti-Patterns</h2><ul>
<li><strong>Read and Write Performance (RP, WP)：</strong>读写性能。通过如果修复好这个AP能获取多少倍的加速。这个指标作为rank依据。</li>
<li><strong>Maintainability (M)</strong>：可维护性 是根据支持新的task时，数据库 在存在这个AP和不存在这个AP需要重构时改变的Number的差异,当number高度依赖于应用中的queries数时，这个AP优先级就会很高。</li>
<li><strong>Data Amplification (DA)</strong>：冗余的列，如age和出生年月；各种冗余不必要的信息。</li>
<li><strong>Data Integrity (DI):</strong> 更新是否保证数据库中保存的是想要的数据</li>
<li><strong>Accuracy (A):</strong> 如是否满足参照一致性</li>
</ul>
<h2 id="Model-for-Ranking-Anti-Patterns"><a href="#Model-for-Ranking-Anti-Patterns" class="headerlink" title="Model for Ranking Anti-Patterns"></a>Model for Ranking Anti-Patterns</h2><ul>
<li>运用开发人员根据自己的开发需求去设置上方metrics的权重。（实际上开发人员也很难去做到这个，这里可以做一个权重自动化设置工具）</li>
<li>当APs之间发生冲突时，即修复一个AP会影响恶化另外一个AP，那就选择优先级高的AP进行修复</li>
</ul>
<h1 id="Fixing-Anti-Patterns"><a href="#Fixing-Anti-Patterns" class="headerlink" title="Fixing Anti-Patterns"></a>Fixing Anti-Patterns</h1><ul>
<li>自动推荐合适应用场景的数据库设计和queries。</li>
</ul>
<p><img src="/2020/07/20/SQLCheck-Automated-Detection-and-Diagnosis-of-SQL-Anti-Patterns/image-20200720130345206.png" alt="image-20200720130345206"></p>
<ul>
<li>两部分的query需要transform: 1. 具有APs的部分 2. 修改APsquery会影响的部分query</li>
<li>如果产生模糊的转换，那就返回一个textual fix，就是说这个工具不足够帮你fix…那它告诉你啥textual fix呢，让开发人员自己看着做</li>
<li>绿色部分解析： 如果query transformation清晰，那就把它解析成语法树，之后转换成sql语句。（数据库的语法树解析感觉有时间可以看看）</li>
</ul>
<h2 id="Query-Repair-Engine"><a href="#Query-Repair-Engine" class="headerlink" title="Query Repair Engine"></a>Query Repair Engine</h2><ul>
<li>rule system是可扩展的，开发人员可以自己把rule按照一定的要求加进去。</li>
<li>首先，规则系统范式使得ap-fix很容易利用修复规则之间复杂的触发交互，从而避免了显式布局流的需要 规则之间的控制（这里没看懂，就直接有道翻译了一下）</li>
</ul>
<h3 id="Rule-Representation"><a href="#Rule-Representation" class="headerlink" title="Rule Representation:"></a>Rule Representation:</h3><ul>
<li>每条规则都包含一个detection function和一个action function</li>
</ul>
<h1 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h1><ul>
<li><p>提供了三个接口：</p>
<ul>
<li><p>Interactive Shell:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Import the anti-pattern finder method</span></span><br><span class="line"><span class="keyword">from</span> sqlcheck.finder <span class="keyword">import</span> find_anti_patterns</span><br><span class="line">query = `INSERT INTO Users VALUES (<span class="number">1</span>, <span class="string">'foo'</span>)`</span><br><span class="line">results = find_anti_patterns(query)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>REST Interface</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HTTP POST /api/check</span><br><span class="line"><span class="attribute">Body</span>: &#123;"query":"INSERT INTO Users VALUES (1,'foo')"&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>GUI Interface</li>
</ul>
<ul>
<li><p>扩展性</p>
<ul>
<li>通用的规则接口（name, type, detection rule, ranking metrics, and repair rule）</li>
<li>context builder：增加应用的context来支持复杂rules</li>
<li>用DBMS-specific解析器代替no-validating解析器</li>
</ul>
</li>
</ul>
<h1 id="Evaluation"><a href="#Evaluation" class="headerlink" title="Evaluation"></a>Evaluation</h1><ul>
<li><p>与DBDEO进行比较（Digital Equipment Corporation. 1992. SQL-92 Standard.</p>
<p><a href="https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt.）" target="_blank" rel="noopener">https://www.contrib.andrew.cmu.edu/~shadow/sql/sql1992.txt.）</a></p>
</li>
</ul>
<h2 id="Detection-of-Anti-Patterns"><a href="#Detection-of-Anti-Patterns" class="headerlink" title="Detection of Anti-Patterns"></a>Detection of Anti-Patterns</h2><ul>
<li>AP-coverage</li>
<li>accuary</li>
<li>Dialect-Coverage：可以适用哪些DBMS</li>
</ul>
<h2 id="Ranking-and-Repair-of-Antipatterns"><a href="#Ranking-and-Repair-of-Antipatterns" class="headerlink" title="Ranking and Repair of Antipatterns"></a>Ranking and Repair of Antipatterns</h2><ul>
<li>针对几个类型的AP进行讨论<ul>
<li>索引过度使用</li>
<li>索引使用不足</li>
<li>不存在外键</li>
<li>枚举类型（只有那几个数值）</li>
</ul>
</li>
</ul>
<h2 id="User-Study"><a href="#User-Study" class="headerlink" title="User Study"></a><strong>User Study</strong></h2><ul>
<li>招募23个学生去<ul>
<li>construst SQL queries</li>
</ul>
</li>
<li>使用GUI 界面追踪这些信息：<ul>
<li>the original SQL queries</li>
<li>the fixes suggested by sqlcheck for the APs detected in the original queries</li>
<li>the re-formulated SQL queries developed by the user that incorporate these fixes.</li>
</ul>
</li>
<li>Web Applications &amp; Databases<ul>
<li>收集github上的sql query，检测人家的应用的query是否存在APs，若存在就在别人的issues中提建议或是给别人发邮件，看看 别人的回馈意见。</li>
</ul>
</li>
<li>Limitations And Future Work<ul>
<li>都是根据定好的rules来发现APs的，对于新的不在规则中的APs不能后发现</li>
</ul>
</li>
</ul>
<h1 id="TOREAD"><a href="#TOREAD" class="headerlink" title="TOREAD"></a>TOREAD</h1><ul>
<li>Tushar Sharma, Marios Fragkoulis, Stamatia Rizou, Magiel Bruntink,and Diomidis Spinellis. 2018. Smelly relations: measuring and understanding database schema quality. In <em>Proc. of ICSE</em>. ACM, 55–64.</li>
<li>[21] Cunningham &amp; Cunningham Inc. 2014. C2 Wiki. <a href="http://wiki.c2.com/?AntiPatternsCatalog" target="_blank" rel="noopener">http://wiki.c2.com/?AntiPatternsCatalog</a></li>
</ul>
<h1 id="对负载生成的启发点"><a href="#对负载生成的启发点" class="headerlink" title="对负载生成的启发点"></a>对负载生成的启发点</h1><ul>
<li>分析数据特征的时候，获取data在相关列上的分布情况，如Unique values,mean,median等（这里lauca貌似没有使用这些特征）</li>
</ul>
<h1 id="研究的主要方向"><a href="#研究的主要方向" class="headerlink" title="研究的主要方向"></a>研究的主要方向</h1><ul>
<li>与SQL Anti-pattern有关，找到、排序（该APs对性能产生影响的大小）、修复APs</li>
</ul>
<h1 id="各项性能指标"><a href="#各项性能指标" class="headerlink" title="各项性能指标"></a>各项性能指标</h1><ul>
<li><strong>Read and Write Performance (RP, WP)</strong></li>
<li><strong>Maintainability (M)</strong></li>
<li><strong>Data Amplification (DA)</strong></li>
<li><strong>Data Integrity (DI)</strong> </li>
<li><strong>Accuracy (A)</strong> </li>
</ul>
<h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><h2 id="数据库即服务"><a href="#数据库即服务" class="headerlink" title="数据库即服务"></a>数据库即服务</h2><ul>
<li>DBaaS是一种云计算服务模型，用户只需要访问数据库即可，无需设置物理硬件，安装软件或配置性能。</li>
<li>Schemate即schema的复数形式，包括table、column、data type、view、stored procedures、relationships、primary key、foreign key等</li>
</ul>
<h2 id="Adjacency-List"><a href="#Adjacency-List" class="headerlink" title="Adjacency List"></a>Adjacency List</h2><ul>
<li><p>具有层次结构的数据</p>
</li>
<li><p>解决方法：邻接表、路径枚举(Path Enumeration)、嵌套集(Nested Sets)、闭包表(Closure Table)</p>
<ul>
<li>邻接表：在树中检索指定节点的祖先节点是很昂贵的</li>
<li>路径枚举：将祖先存储成字符串(以路径的形式)，缺点：数据库不能强制规定路径是正确形成的，或者路径中的值对应于存在的节点。维护路径字符串取决于应用程序代码，并验证它的开销是非常昂贵的。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222612709-755258849.png" alt="img"></p>
<ul>
<li><p>嵌套集：根据深度优先额外维护nsleft和nsright，便于寻找节点的所有祖先节点和所有的孩子结点，但插入和移动节点很复杂，需要重复编号nsleft和nsright，当树的使用设计频繁的插入，嵌套集不是最佳选择。</p>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222742363-381067227.png" alt="img"></p>
</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222746488-1903425778.png" alt="img"></p>
<ul>
<li>闭包表：多增加一个表结构，专门用来存所有的祖孙信息，不只是父子信息，更便于查询。</li>
</ul>
<p><img src="https://images2018.cnblogs.com/blog/1013949/201804/1013949-20180415222757572-1586364911.png" alt="img"></p>
</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/16/MYSQL-必知必会/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/MYSQL-必知必会/" itemprop="url">MYSQL 必知必会</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T16:23:07Z">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础书本/" itemprop="url" rel="index">
                    <span itemprop="name">基础书本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="使用MySQL基本指令"><a href="#使用MySQL基本指令" class="headerlink" title="使用MySQL基本指令"></a>使用MySQL基本指令</h2><ul>
<li>use database1; 切换数据库</li>
<li>SHOW DATABASES; 显示所有数据库</li>
<li>SHOW TABLES;</li>
<li>SHOW COLUMNS FROM customers ;  ===  DESCRIBE CUSTOMERS;</li>
</ul>
<h2 id="limit关键字："><a href="#limit关键字：" class="headerlink" title="limit关键字："></a>limit关键字：</h2><ul>
<li>Limit 3,4 ==LIMIT 4 OFFSET 3; 从行3开始，返回4行；检索出来的第一行是行0</li>
</ul>
<h2 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h2><ul>
<li>通常ORDER BY子句中使用的列将是为显示所选择的列。但是，实际上并不一定，用<strong>非检索的列排序</strong>数据是完全合法的。</li>
<li>默认是升序</li>
<li>对于文本性的数据进行排序时，A被视为与a相同，这是MySQL（和大多数数据库管理系统）的默认行为。但是，许多数据库管理员能够在需要时改变这种行为。</li>
</ul>
<h2 id="使用IN操作的优点"><a href="#使用IN操作的优点" class="headerlink" title="使用IN操作的优点"></a>使用IN操作的优点</h2><ul>
<li>语法更清楚且直观</li>
<li>一般比OR操作符清单执行更快</li>
<li>最大优点是可以包含其他SELECT语句，使得能够更动态地建立WHERE子句。</li>
</ul>
<h2 id="MySQL中NOT"><a href="#MySQL中NOT" class="headerlink" title="MySQL中NOT"></a>MySQL中NOT</h2><ul>
<li>支持对<strong>IN、BETWEEN和EXISTS</strong>子句取反，这与多数其他DBMS允许使用NOT对各种条件取反有很大的差别。</li>
</ul>
<h2 id="SQL中的谓词"><a href="#SQL中的谓词" class="headerlink" title="SQL中的谓词"></a>SQL中的谓词</h2><ul>
<li><p>谓词与函数的区别：对于通常的函数来说，返回值有可能是数字、字符串或者日期等，但是谓词的返回值都是真值（true/false/unknown）。</p>
</li>
<li><p><strong>LIKE、BETWEEN、IS NULL、IS NOT NULL、IN、EXISTS</strong></p>
<ul>
<li><p>LIKE——字符串的部分一致查询（模糊查询）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">①前方一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'aaa%'</span>;</span><br><span class="line"></span><br><span class="line">②中间一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%aaa%'</span>;</span><br><span class="line">    </span><br><span class="line">③后方一致<span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span> <span class="keyword">where</span> username <span class="keyword">like</span> <span class="string">'%aaa'</span>;</span><br><span class="line"></span><br><span class="line">%可以匹配0个字符。</span><br></pre></td></tr></table></figure>
</li>
<li><p>BETWEEN（and）——范围查询</p>
</li>
</ul>
</li>
</ul>
<h2 id="用通配符的技巧"><a href="#用通配符的技巧" class="headerlink" title="用通配符的技巧"></a>用通配符的技巧</h2><ul>
<li>不要过度使用通配符，注意通配符的位置。</li>
</ul>
<h1 id="MySQL的正则表达式"><a href="#MySQL的正则表达式" class="headerlink" title="MySQL的正则表达式"></a>MySQL的正则表达式</h1><ul>
<li><p>REGEXP和LIKE的区别：LIKE匹配整个串而REGEXP匹配子串</p>
</li>
<li><p>不区分大小写，为区分大小写，可使用BINARY关键字</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WHERE prod_name REGEXP BINARY 'JetPack .000'</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行OR匹配  ‘|’</p>
</li>
<li><p>匹配几个字符之一 [123] 表示匹配1或2或3，与1|2|3不同，前者是[1|2|3]的缩写</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> prod_name</span><br><span class="line"><span class="keyword">From</span> products</span><br><span class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'[123] Ton'</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配范围 [1-3]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT prod_name</span><br><span class="line">From products</span><br><span class="line">WHERE prod_name REGEXP &apos;[1-3] Ton&apos;</span><br><span class="line">ORDER BY prod_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>匹配特殊字符，如 <strong>. [] | ()</strong> ，用\\为前导，如\\.表示查找. \\也用来引用元字符</p>
</li>
<li><p>匹配字符类</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618114655099.png" alt="image-20200618114655099"></p>
</li>
</ul>
<h2 id="匹配多个实例"><a href="#匹配多个实例" class="headerlink" title="匹配多个实例"></a>匹配多个实例</h2><ul>
<li><p>对匹配的数目进行更强的控制</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618114850214.png" alt="image-20200618114850214"></p>
<h2 id="匹配定位符"><a href="#匹配定位符" class="headerlink" title="匹配定位符"></a>匹配定位符</h2></li>
<li><p>为了匹配特定位置的文本</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200618115227926.png" alt="image-20200618115227926"></p>
<ul>
<li><p>^的双重用途：</p>
<ul>
<li><p>在集合中[]，用它来否限定该集合</p>
</li>
<li><p>用来指串的开始处</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="创建计算字段"><a href="#创建计算字段" class="headerlink" title="创建计算字段"></a>创建计算字段</h1><h2 id="拼接："><a href="#拼接：" class="headerlink" title="拼接："></a>拼接：</h2><ul>
<li><p>多数DBMS使用<strong>+</strong>或者<strong>||</strong>来实现拼接，MySQL则使用<strong>Concat()</strong>函数来实现。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> <span class="keyword">Concat</span>(vend_name,<span class="string">'('</span>,vend_country,<span class="string">')'</span>)</span><br><span class="line"><span class="keyword">From</span> vendors</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name;</span><br><span class="line"></span><br><span class="line">Return: ACME(USA)</span><br></pre></td></tr></table></figure>
</li>
<li><p>RTrim()函数： 删除数据右侧多余的空格。如RTrim(vend_name)</p>
</li>
<li><p>LTrim()函数：去掉串左边的空格</p>
</li>
<li><p>Trim()函数：去掉串左右两边的空格</p>
</li>
<li><p>取列的别名</p>
</li>
</ul>
<h1 id="使用数据处理函数"><a href="#使用数据处理函数" class="headerlink" title="使用数据处理函数"></a>使用数据处理函数</h1><ul>
<li>以下的函数都是大多数SQL实现支持的。</li>
</ul>
<h2 id="文本处理函数："><a href="#文本处理函数：" class="headerlink" title="文本处理函数："></a>文本处理函数：</h2><ul>
<li>其中SOUNDEX()考虑了类似的发音字符和音节，使得能对串进行发音比较而不是字母比较。</li>
</ul>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620111648327.png" alt="image-20200620111648327"></p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620111657883.png" alt="image-20200620111657883"></p>
<h2 id="日期和时间处理函数"><a href="#日期和时间处理函数" class="headerlink" title="日期和时间处理函数"></a>日期和时间处理函数</h2><ul>
<li>MySQL使用的日期格式，不管是插入或更新表值还是用WHERE子句进行过滤，日期必须为格式yyyy-mm-dd。</li>
</ul>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112323444.png" alt="image-20200620112323444"></p>
<h2 id="数值处理函数"><a href="#数值处理函数" class="headerlink" title="数值处理函数"></a>数值处理函数</h2><ul>
<li><p>在主要DBMS的函数中，数值函数是最一致最统一的函数</p>
<p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112642455.png" alt="image-20200620112642455"></p>
</li>
</ul>
<h1 id="汇总数据"><a href="#汇总数据" class="headerlink" title="汇总数据"></a>汇总数据</h1><h2 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h2><p><img src="/2020/07/16/MYSQL-必知必会/image-20200620112834932.png" alt="image-20200620112834932"></p>
<ul>
<li>Distinct关键字：后面必须使用列名。</li>
</ul>
<h1 id="分组数据"><a href="#分组数据" class="headerlink" title="分组数据"></a>分组数据</h1><ul>
<li><p>使用WITH ROLLUP关键字，可以得到每个分组以及每个分组汇总级别（针对每个分组）的值</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_id,<span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</span><br><span class="line"><span class="keyword">FROM</span> products</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id <span class="keyword">WITH</span> <span class="keyword">ROLLUP</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>WHERE过滤行，HAVING过滤分组</p>
</li>
</ul>
<h1 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h1><ul>
<li><p>笛卡尔积：由没有联结条件的表关系返回的结果</p>
</li>
<li><p>内部联结，也称为等值联结</p>
<ul>
<li><p>ANSI SQL规范首选<strong>INNER JOIN</strong>语法，而不是=</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> vend_name,prod_name,prod_price</span><br><span class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</span><br><span class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h1 id="乱七八糟"><a href="#乱七八糟" class="headerlink" title="乱七八糟"></a>乱七八糟</h1><ul>
<li>没有主键，更新或删除表中的特定行很困难，因为没有安全的方法保证只涉及相关的行。</li>
<li>MySQL在执行匹配时默认不区分大小写。根据MySQL的配置方式，搜索可以是区分大小写的。</li>
<li>可移植的：能运行在多个系统上的代码</li>
<li>可伸缩性：能够适应不断增加的工作量而不失败。</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/16/Head-First-Java/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/16/Head-First-Java/" itemprop="url">Head First Java</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-15T16:17:54Z">
                2020-07-15
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/基础书本/" itemprop="url" rel="index">
                    <span itemprop="name">基础书本</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h1><ul>
<li>两种变量：<ul>
<li>primitive主数据类型</li>
<li>引用变量（其值位于堆上）【相当于遥控器】</li>
</ul>
</li>
<li>对象：状态（实例变量 instance varible)、行为(方法 method)</li>
<li>主要在类中使用封装 (set 函数) 来隐藏数据<ul>
<li>将实例变量标记为private, 将get/set方法标记为public</li>
</ul>
</li>
<li>实例变量永远都会有默认值，但局部变量未被初始化 使用时被给出error，即其没有默认值<ul>
<li>integers  0</li>
<li>floating 0.0</li>
<li>boolean  false</li>
<li>reference  null</li>
</ul>
</li>
<li>变量的比较：<ul>
<li>使用==比较两个primitive 主数据类型，或者判断两个号|用是否引用同一个对象。</li>
<li>使用 equals()来判断两个对象是否在意义上相等。（像是两个 String对像是否带有相同的字节组合）</li>
</ul>
</li>
</ul>
<h1 id="构造器与垃圾收集器"><a href="#构造器与垃圾收集器" class="headerlink" title="构造器与垃圾收集器"></a>构造器与垃圾收集器</h1><h2 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h2><ul>
<li>对象在堆上，类中的实例变量（实质上是对象的一部分）自然也在堆上</li>
<li>局部变量和方法调用在栈上，对象引用变量与primitive主数据类型变量都是放在栈上</li>
</ul>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><ul>
<li>当类中手动写了一个带有参数的构造函数时，编译器不会主动帮你写一个无参数的构造函数，因此需要自己写！！</li>
<li>使用this()从某个构造函数调用同一个类的另外一个构造函数。this()只能用在构造函数中，且必须是第一行语句。super()与this()不能兼得。</li>
</ul>
<ul>
<li>、</li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/14/The-ArtScience-and-Engineering-of-Fuzzing-A-Survey-/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/14/The-ArtScience-and-Engineering-of-Fuzzing-A-Survey-/" itemprop="url">The ArtScience and Engineering of Fuzzing: A Survey</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-13T22:45:48Z">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/Test-Case-Geneation/" itemprop="url" rel="index">
                    <span itemprop="name">Test Case Geneation</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>20200713 15:01 结  </p>
<ul>
<li>关键词：自动化软件测试，模糊化，软件安全</li>
<li>目的：作为一个survey，围绕模糊化，给它<strong>下定义</strong>，总结对软件测试提出的模糊化方面的改进，发掘有哪些创新点</li>
<li>领域： 软件测试，模糊化</li>
</ul>
<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul>
<li>模糊化是什么？<ul>
<li>使用生成的输入（输入存在语义和语法错误）重复运行一个项目。</li>
</ul>
</li>
<li>目前模糊化有哪些问题？<ul>
<li>一些fuzzer工具的源代码和手册实际达不到描述的那样</li>
<li>不同fuzzer工具使用的术语各大相同</li>
</ul>
</li>
<li>Fuzzing定义<ul>
<li>从fuzz输入空间生成样例测试Program，并突出<strong>PUT(Program Under Test)</strong>期望的输入空间</li>
</ul>
</li>
<li>Fuzz Testing定义<ul>
<li>使用fuzzing技术去测试看是否PUT违背安全政策</li>
<li>目的：找出program中影响安全的bugs</li>
</ul>
</li>
<li>Fuzzer定义<ul>
<li>在一个PUT上执行fuzzing testing的Program</li>
</ul>
</li>
<li>Fuzz Campaign<ul>
<li>针对一条特定安全政策，一个fuzzer在PUT上的一个特定的执行，相当于专门针对哪个安全，制作出一些sample去用fuzzer执行。</li>
</ul>
</li>
<li>Bug Oracle<ul>
<li>作为fuzzer的一部分Program，检测给定的PUT执行是否违反特定安全政策</li>
</ul>
</li>
<li>Fuzz Configuration<ul>
<li>Fuzz算法的参数配置，依赖于特定的fuzz algorithm</li>
<li></li>
</ul>
</li>
<li>设计测试工具的时候，一定先熟悉源代码和PUT的相关知识！！！</li>
</ul>
<h2 id="Fuzz-Testing-算法"><a href="#Fuzz-Testing-算法" class="headerlink" title="Fuzz Testing 算法"></a>Fuzz Testing 算法</h2><ul>
<li>有两个部分：对配置进行预处理；迭代（包括Schedule,InputGen,InputEval,ConfUpdate,Continue）<ul>
<li>PREPROCESS：执行大量操作，比如插入一些功能性代码到PUTs中，或是检测种子文件（产生测试样例）的执行速度</li>
<li>第二部分的迭代的流程：先选择一个fuzz配置；根据配置中的参数生成测试样例；用测试样例和oracle bug检测是否违背安全政策（这个应该可以自己规定），这时可以得到execinfos，这大概是为了变动配置，为了之后能选取到更具有代表性的配置去生成测试样例；根据execinfos,改变fuzz配置；最后判断fuzz配置是否进行下一轮的迭代。</li>
</ul>
</li>
</ul>
<h2 id="Fuzzer的分类"><a href="#Fuzzer的分类" class="headerlink" title="Fuzzer的分类"></a>Fuzzer的分类</h2><ul>
<li><p>根据在每次fuzz run的时候fuzzer观察到的东西多少，以下只是安全专家的一致认同，在实际使用的时候，三者的区别不太明显。</p>
</li>
<li><p>黑盒fuzzer</p>
<ul>
<li>只能看到PUT输入和输出的表现，有一些还考虑输入的结构信息</li>
</ul>
</li>
<li>白盒fuzzer<ul>
<li>可以观察到PUT的内部信息以及执行过程中的收集到的信息</li>
</ul>
</li>
<li>灰盒fuzzer<ul>
<li>可以观察到一部分PUT的内部信息和它的执行，但是不能得到PUT完成的语义，且只能对PUT执行轻量级的分析和对执行收集动态信息。即收集一些近似信息</li>
</ul>
</li>
</ul>
<h1 id="PREPROCESS"><a href="#PREPROCESS" class="headerlink" title="PREPROCESS"></a>PREPROCESS</h1><ul>
<li>预处理包括对PUT做一些性能监控（灰盒、白盒都能去PUT中获取一些反馈信息）[对PUT进行插桩]，去除冗余的配置（像种子选择），修剪种子，生成驱动应用。</li>
</ul>
<h2 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h2><ul>
<li>白盒、灰盒中用来收集最有价值反馈的一种方法，代码插桩（在被测程序中插入完成相应工作的代码，即代码插桩技术，来获取程序中可执行语句被执行（即被覆盖）的情况）</li>
<li>分为static instrumentation和dynamic instrumentation，前者一般在源代码的编译阶段执行，后者一般在运行阶段执行。</li>
</ul>
<h3 id="Execution-Feedback"><a href="#Execution-Feedback" class="headerlink" title="Execution Feedback"></a>Execution Feedback</h3><ul>
<li>灰盒fuzzers将执行反馈作为输入去优化测试样例，AFL等文章计算分支覆盖率作为反馈内容，但容易发生分支冲突，对此CollAFL提出相应解决方法。</li>
</ul>
<h3 id="In-Memory-Fuzzing"><a href="#In-Memory-Fuzzing" class="headerlink" title="In-Memory Fuzzing"></a>In-Memory Fuzzing</h3><ul>
<li>为了最小化执行开销，每次fuzz迭代只fuzz一部分的PUT,program会保留PUT的快照，下次fuzz新的测试样例时需要恢复memory快照。这种快照可以避免执行不必要的启动代码。</li>
<li>in-memiry API fuzzing通过一个函数而不是每次迭代恢复PUT的状态，这种方式尽管有效，但是找到的bugs却不完整，因为可能调用不到这种函数（我猜是函数名生成有问题？？）</li>
</ul>
<h3 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a>Thread Scheduling</h3><ul>
<li>随机调度线程对找到race condition bugs很有效。</li>
</ul>
<h2 id="Seed-Selection"><a href="#Seed-Selection" class="headerlink" title="Seed Selection"></a>Seed Selection</h2><ul>
<li>希望选取最小的种子集合最大化覆盖率（如节点覆盖率）</li>
<li>覆盖率评价指标：<ul>
<li>branch coverage（计算分支的执行次数），当测试样例在分支执行次数上的数量级不同时才认为它们是不同的</li>
<li>the number of executed instructions,executed branches,and unique basic block。希望将最长的执行路径的测试样例增加到minset中。</li>
</ul>
</li>
</ul>
<h2 id="Seed-Trimming"><a href="#Seed-Trimming" class="headerlink" title="Seed Trimming"></a>Seed Trimming</h2><ul>
<li><p>在preprocess中执行，或作为CONFUPDATE的一部分</p>
</li>
<li><p>在AFL中只要修改过的seed能够达到和原先种子一样的覆盖率，就修剪掉原先种子。</p>
</li>
<li>[177]发现size小的种子没啥用</li>
</ul>
<h2 id="Preparing-a-Driver-Application"><a href="#Preparing-a-Driver-Application" class="headerlink" title="Preparing a Driver Application"></a>Preparing a Driver Application</h2><ul>
<li>给fuzzer一开始的时候准备一个驱动器（这里不太理解）</li>
</ul>
<h1 id="SCHEDULING"><a href="#SCHEDULING" class="headerlink" title="SCHEDULING"></a>SCHEDULING</h1><ul>
<li>选择一个fuzz 配置为下轮fuzz迭代，不同的fuzzer类型具有不同的配置。这里主要的研究点是提出创新性的scheduling算法。</li>
</ul>
<h2 id="The-Fuzz-Cofiguration-Scheduling-FCS-Problem"><a href="#The-Fuzz-Cofiguration-Scheduling-FCS-Problem" class="headerlink" title="The Fuzz Cofiguration Scheduling (FCS) Problem"></a>The Fuzz Cofiguration Scheduling (FCS) Problem</h2><ul>
<li>挑选一个可能产生最好结果的配置（评判可能依据 find the most number of unique bugs[unique bugs不知道咋翻译], maximize the coverage]。在挑选的时候考虑explore（关于每个配置获取更为准确的信息）和exploit（获取好的结果），做这两者的trade-off。</li>
</ul>
<h2 id="Black-box-FCS-Algorithms"><a href="#Black-box-FCS-Algorithms" class="headerlink" title="Black-box FCS Algorithms"></a>Black-box FCS Algorithms</h2><ul>
<li>黑盒用到的反馈信息：crashes和bug的数量毕竟执行时间</li>
<li>[225]提炼数学模型，WCCP/UW，由于反馈信息会随着配置结果变差，因此选择一些配置不会导致反馈decay。为了将crashes或bugs / time来修改反馈信息，目的是为了能更快速地进行配置（感觉是把time因素考虑进去）。</li>
</ul>
<h2 id="Grey-box-FCS-Algorithms"><a href="#Grey-box-FCS-Algorithms" class="headerlink" title="Grey-box FCS Algorithms"></a>Grey-box FCS Algorithms</h2><ul>
<li>灰盒用到的反馈信息：黑盒能用到的，达到的覆盖率等等</li>
<li>AFL认为执行最快，input最少的是<strong>fit</strong></li>
<li><p>AFLFast在AFL基础上做了三点改进</p>
<ul>
<li>增加两条重要准则：<ul>
<li>AFLFast喜欢被选中<strong>最少</strong>的配置</li>
<li>AFLFast喜欢<strong>最少</strong>选择的路径</li>
</ul>
</li>
<li>AFLFast在AFL增加了优先级，替代AFL中的圆形选择</li>
<li>AFLFast每个配置被选中次数是动态改变的</li>
</ul>
</li>
<li><p>AFLGo修改了AFLFast优先级的特征，目的是为了找到特定的程序位置。</p>
</li>
</ul>
<h1 id="INPUT-GENERATION"><a href="#INPUT-GENERATION" class="headerlink" title="INPUT GENERATION"></a>INPUT GENERATION</h1><ul>
<li>分为generation-based和mutation-based，前者是基于model的，后者是通过mutate seed。</li>
</ul>
<h2 id="Model-based-Generation-based-Fuzzers"><a href="#Model-based-Generation-based-Fuzzers" class="headerlink" title="Model-based (Generation-based) Fuzzers"></a><strong>Model-based (Generation-based) Fuzzers</strong></h2><ul>
<li>预定义或用户提供的模型</li>
<li>推断模型可能发生在PREPROCESS阶段也可能在CONFUPDATE阶段<ul>
<li>在PREPROCESS阶段，在PUT中搜找可用的数据（如文字），去预测合适的输出</li>
<li>在CONFUPDATE阶段，每次迭代更新model</li>
</ul>
</li>
<li>编译器模型（不太能理解这个模型）<ul>
<li>解析特定的文件格式</li>
</ul>
</li>
</ul>
<h2 id="Model-less-Mutation-based-Fuzzers"><a href="#Model-less-Mutation-based-Fuzzers" class="headerlink" title="Model-less (Mutation-based) Fuzzers"></a><strong>Model-less (Mutation-based) Fuzzers</strong></h2><ul>
<li>需要seed-based输入生成和<strong>白盒输入生成</strong>。</li>
<li>Bit-flipping：翻转固定/不固定数量bit位，用mutation ratio决定翻转多少数量的bit位。因此，找到一个合适的mutation ratio数值至关重要。</li>
<li><em>Arithmetic Mutation</em>：将选择的字节序列视为一个整数，对整数进行处理（不太能理解）</li>
<li><em>Block-based Mutation</em>：以block为单位，进行mutation</li>
<li><em>Dictionary-based Mutation</em>：对具体的字符（数值）进行mutation（不太能理解）</li>
</ul>
<h2 id="White-box-Fuzzers"><a href="#White-box-Fuzzers" class="headerlink" title="White-box Fuzzers"></a>White-box Fuzzers</h2><ul>
<li><p>先使用白盒程序分析找到PUT的信息，用这信息去进行黑盒or灰盒fuzzing。</p>
</li>
<li><p>Dynamic symbolic execution：比灰盒和黑盒慢很多，因为它需要对PUT的每条指令进行插桩和分析，这方面的研究都聚集在如何减少它的代价方面。</p>
</li>
<li><p><em>Guided Fuzzing</em>：先对PUT进行分析（静态or动态分析）来获取有用的信息；再利用这个信息去生成test case。这上面的研究一方面需要减少分析产生的代价。</p>
</li>
<li><p><em>PUT Mutation</em>：不重要。。</p>
</li>
</ul>
<h1 id="INPUT-EVALUATION"><a href="#INPUT-EVALUATION" class="headerlink" title="INPUT EVALUATION"></a>INPUT EVALUATION</h1><h2 id="Bug-Oracles"><a href="#Bug-Oracles" class="headerlink" title="Bug Oracles"></a><strong>Bug Oracles</strong></h2><ul>
<li>有三个方面的侦测：内存安全问题（是否访问到不安全的内存、控制流的完整性[啥意思]）、访问到未被定义的行为（如编译器不同，程序猿只考虑了某些编译器情况下可行，但有些不可行却忽略了）、输入的合法性（比如<strong>SQL访问可能对数据库引擎存在一些破坏</strong>）</li>
</ul>
<h2 id="Execution-Optimizations"><a href="#Execution-Optimizations" class="headerlink" title="Execution Optimizations"></a><strong>Execution Optimizations</strong></h2><ul>
<li>由于迭代需要每次都初始化PUT进程，需要耗费大量的时间，对此，AFL提供了一个fork-server去让迭代去从进行初始化好的进行进程中fork一下。</li>
</ul>
<h2 id="Triage"><a href="#Triage" class="headerlink" title="Triage"></a>Triage</h2><ul>
<li>分析和报告导致违反政策（感觉就是不安全的）的进程，分为三步：去重复、优先级、测试样例最小化。</li>
</ul>
<h3 id="Deduplication"><a href="#Deduplication" class="headerlink" title="Deduplication"></a>Deduplication</h3><ul>
<li>去重复：若该test case返回的Bug已经被以前的test case找到了，这个test case就不要了。能得到test case集合，该集合中每个test case都能触发唯一的bug。去重复有三种主要的实现方式：<ul>
<li>stack backtrace hashing<ul>
<li>记录了crash时的stack backtrace(如：main → d → c → b → a → foo )，当其他crash时的stack backtrace的后五个也是这个时候，认为他们重复, 这是major hash。而minor hash还考虑到line number（感觉是数量）。但这样做事基于一种假设，即相似的crash是由相似的bugs引起的，但这假设未被验证，且能举出反例。</li>
</ul>
</li>
<li>coverage-based deduplication<ul>
<li>在PUT中插桩记录PUT每次执行的edge覆盖率，根据这个信息选取seeds，AFL认为当crash覆盖到之前未见到的edge或者未覆盖到之前在所有其他crashes中都覆盖到的edge时，认为该crash是唯一的。</li>
</ul>
</li>
<li>semantics-aware deduplication<ul>
<li>从每个crash处反向分析，找到那个function，根据function来对crashes进行分类。(怎么那么奇怪)</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>### </p>
<h3 id="Prioritization-and-Exploitability"><a href="#Prioritization-and-Exploitability" class="headerlink" title="Prioritization and Exploitability"></a>Prioritization and Exploitability</h3><ul>
<li><p>根据一个crash的可利用性来划分优先级。Microsoft’s !exploitable的优先级划分： EXPLOITABLE &gt; PROBABLY_EXPLOITABLE &gt; UNKNOWN &gt;</p>
<p>NOT_LIKELY_EXPLOITABLE,</p>
</li>
</ul>
<h3 id="Test-case-minimization"><a href="#Test-case-minimization" class="headerlink" title="Test case minimization"></a>Test case minimization</h3><ul>
<li>利用bug oracle进行test case 最小化。许多fuzzers都针对自己特定的情况选用test case最小化算法。</li>
</ul>
<h1 id="CONFIGURATION-UPDATING"><a href="#CONFIGURATION-UPDATING" class="headerlink" title="CONFIGURATION UPDATING"></a>CONFIGURATION UPDATING</h1><ul>
<li>可用来区别是白盒fuzzer、黑盒fuzzer、灰盒fuzzer。由于黑盒只能用到Oracle bug(不能得到PUT的内部信息)大部分Conf都不被修改。</li>
</ul>
<h2 id="Evolutionary-Seed-Pool-Update"><a href="#Evolutionary-Seed-Pool-Update" class="headerlink" title="Evolutionary Seed Pool Update"></a>Evolutionary Seed Pool Update</h2><ul>
<li>灰盒fuzzer大多基于遗传算法进行展开，EA-based fuzzers大多数使用node或者Branch覆盖度作为fitness function.[后面举例没仔细看]</li>
</ul>
<h2 id="Maintaining-a-Minset"><a href="#Maintaining-a-Minset" class="headerlink" title="Maintaining a Minset"></a>Maintaining a Minset</h2><ul>
<li>赋予favorable fuzzing conf以高的被选择进行fuzzing的权重。思想是：需要少的test case最大化coverage评价指标。</li>
</ul>
<p>​    </p>
<h1 id="Links"><a href="#Links" class="headerlink" title="Links:"></a>Links:</h1><ul>
<li>paper: <a href="https://ieeexplore.ieee.org/abstract/document/8863940" target="_blank" rel="noopener">https://ieeexplore.ieee.org/abstract/document/8863940</a></li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/" itemprop="url">Detect logic bugs in DBMS的三篇论文</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-13T20:27:12Z">
                2020-07-13
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/DBMS-Testing/" itemprop="url" rel="index">
                    <span itemprop="name">DBMS Testing</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Testing-Database-Engines-via-Pivoted-Query-Synthesis论文"><a href="#Testing-Database-Engines-via-Pivoted-Query-Synthesis论文" class="headerlink" title="Testing Database Engines via Pivoted Query Synthesis论文"></a>Testing Database Engines via Pivoted Query Synthesis论文</h1><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>随机生成table和rows</li>
<li>从每个表随机生成<strong>一行</strong></li>
<li>根据选择的rows随机生成表达式并评估结果</li>
<li>修改表达式 直到返回真</li>
</ul>
<h2 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h2><ul>
<li>检测logic bug，logic bug即是否返回正常的行</li>
</ul>
<h2 id="研究常用的方法"><a href="#研究常用的方法" class="headerlink" title="研究常用的方法"></a>研究常用的方法</h2><ul>
<li><p>差异性测试，不适用于所有DBMS</p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202218604.png" alt="image-20200618202218604"></p>
</li>
</ul>
<h2 id="各项性能指标"><a href="#各项性能指标" class="headerlink" title="各项性能指标"></a>各项性能指标</h2><ul>
<li>观察是否返回 随机生成的row</li>
</ul>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul>
<li>不适用于大数据集</li>
<li>可能只能做where里面的AST树</li>
</ul>
<h2 id="扩展知识点"><a href="#扩展知识点" class="headerlink" title="扩展知识点"></a>扩展知识点</h2><ul>
<li>AST树</li>
<li>差异性比较</li>
</ul>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202406294.png" alt="image-20200618202406294"></p>
<h1 id="Detecting-Optimization-Bugs-in-Database-Engines-via-Non-Optimizing-Reference-Engine-Construction论文"><a href="#Detecting-Optimization-Bugs-in-Database-Engines-via-Non-Optimizing-Reference-Engine-Construction论文" class="headerlink" title="Detecting Optimization Bugs in Database Engines via Non-Optimizing Reference Engine Construction论文"></a>Detecting Optimization Bugs in Database Engines via Non-Optimizing Reference Engine Construction论文</h1><h2 id="主要内容-1"><a href="#主要内容-1" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li><p>不正常的优化可能会导致logic bug</p>
</li>
<li><p>核心：重写DBMS不能优化的潜在随机生成优化的query</p>
</li>
<li><p>让DBMS不做优化，做全表的扫描</p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618192500114.png" alt="image-20200618192500114"></p>
<ul>
<li>左边是原本数据库会优化的，右边是数据库不会优化的。</li>
</ul>
</li>
<li><p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618202756024.png" alt="image-20200618202756024"></p>
</li>
</ul>
<h1 id="Ternary-Logic-Partitioning-Detecting-Logic-Bugs-in-Database-Management-Systems"><a href="#Ternary-Logic-Partitioning-Detecting-Logic-Bugs-in-Database-Management-Systems" class="headerlink" title="Ternary Logic Partitioning: Detecting Logic Bugs in Database Management Systems"></a>Ternary Logic Partitioning: Detecting Logic Bugs in Database Management Systems</h1><h2 id="主要内容-2"><a href="#主要内容-2" class="headerlink" title="主要内容"></a>主要内容</h2><ul>
<li>query分区，将一条给定原始的query，分成多份更复杂的queries，每个部分都计算结果的一部分。</li>
<li><p>三元逻辑分区：</p>
<ul>
<li>基于一个布尔谓词p计算成True,False,NULL的观察</li>
</ul>
</li>
<li><p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618192837917.png" alt="image-20200618192837917"></p>
</li>
</ul>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618203712878.png" alt="image-20200618203712878"></p>
<p><img src="/2020/07/14/Detect-logic-bugs-in-DBMS的三篇论文/image-20200618203725136.png" alt="image-20200618203725136"></p>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-categories" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://luyiqu.github.io/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="luyiqu">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="瞿璐祎的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/" itemprop="url">Automated Grading of SQL Queries 论文解读</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-06-20T10:50:42Z">
                2020-06-20
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/SQL-Queries-Paper/" itemprop="url" rel="index">
                    <span itemprop="name">SQL Queries Paper</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><ul>
<li><p>自动给学生的sql query打分，局部打分，通过判断错误严重的程度。</p>
</li>
<li><p>采用 <strong>weighted equivalence edit distance metric</strong>，找到最小的编辑序列，能将原始错误的sql query转为正确的query。</p>
</li>
<li><p>使用query规范化规则针对语法和语义进行规划</p>
<ul>
<li>语法，如将Not(A&gt;B) 替换为A&lt;=B; 将操作构建一棵flattened tree</li>
<li>语义，将query中主键上的distinct移除，将query中冗余的关系移除。</li>
</ul>
</li>
<li><p>Flattened Tree Structure</p>
<p><img src="/2020/06/20/Automated-Grading-of-SQL-Queries论文解析/image-20200620103146416.png" alt="image-20200620103146416.png"></p>
<ul>
<li>将query中有连接关系的都flatten一下，转化为等价形式。</li>
<li>针对flattened tree，谓词/投影/聚类操作都作为一棵棵子树</li>
</ul>
</li>
<li><p>计算规范化的编辑距离</p>
<ul>
<li>对于每个组件（子树）分别计算编辑距离，然后找到每个quert的带权距离。Σc∈<em>components</em>W<strong>c <em>∗</em> E</strong>c</li>
</ul>
</li>
<li><p>根据编辑距离给分</p>
</li>
</ul>
<h1 id="领域"><a href="#领域" class="headerlink" title="领域"></a>领域</h1><ul>
<li>指出错误sql query错在那个部分，也就是做最小的改动，能让sql query变成正确的。</li>
</ul>
<h1 id="研究常用的方法"><a href="#研究常用的方法" class="headerlink" title="研究常用的方法"></a>研究常用的方法</h1><ul>
<li>XData通过比较正确query和学生query得到的结果，对学生 sql query进行二分类，即判别正确or错误，但太简单了，想得到更细致的。</li>
<li>根据正确query和学生query返回结果交集所占正确结果的比例，但有可能因为一个很小的错误得出的结果很差，导致分数低。</li>
<li>学生的sql query需要做<strong>多少个变化</strong>才能和正确的sql等价，但许多具有语义差异的sql在返回的结果却没什么差异。<strong>（本文）</strong>针对此，使用大量query规范化技巧移除学生和正确的queries的不相关的语法和语义差别。但是需要给出多个正确的queries，将学生query与其相比较，选出匹配度最高的query。这个问题可以抽象为图中找最短路径，提出一个贪心启发性技巧。</li>
</ul>
<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><ul>
<li>基于规范化编辑距离的给分有可能是不公平的，在规范化部分还存在一些问题。</li>
</ul>
<h1 id="实验部分和讨论部分"><a href="#实验部分和讨论部分" class="headerlink" title="实验部分和讨论部分"></a>实验部分和讨论部分</h1><ul>
<li><p>随机创建一对不正确的学生queries，a和b，让两个志愿者对每对queries分类，第一类是a queriy的分高，第二类是b query的分高，第三类是a,b query的分数一样高。</p>
</li>
<li><p>potentially an infinite number of edit options <strong>are possible</strong></p>
</li>
</ul>
<h1 id="对负载生成的启发点"><a href="#对负载生成的启发点" class="headerlink" title="对负载生成的启发点"></a>对负载生成的启发点</h1><h2 id="SQL-QUERY-规范化"><a href="#SQL-QUERY-规范化" class="headerlink" title="SQL QUERY 规范化"></a>SQL QUERY 规范化</h2><ul>
<li><p>B. Chandra, M. Joseph, B. Radhakrishnan, S. Acharya, and S. Sudarshan.</p>
<p>Partial marking for automated grading of SQL queries. <em>PVLDB (Demo)</em>,</p>
<p>9(13):1541–1544, 2016.</p>
</li>
</ul>
<h1 id="Source-Code"><a href="#Source-Code" class="headerlink" title="Source Code"></a>Source Code</h1><ul>
<li><a href="https://www.cse.iitb.ac.in/infolab/xdata" target="_blank" rel="noopener">https://www.cse.iitb.ac.in/infolab/xdata</a></li>
<li><a href="https://gitlab.com/xdata/xdata-web/-/tree/developer/XDataGrading/src" target="_blank" rel="noopener">https://gitlab.com/xdata/xdata-web/-/tree/developer/XDataGrading/src</a></li>
</ul>

          
        
      
    </div>
    
    
    
<div>
      
</div>
    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="luyiqu">
            
              <p class="site-author-name" itemprop="name">luyiqu</p>
              <p class="site-description motion-element" itemprop="description">blog</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">28</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">27</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">luyiqu</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>





        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> 访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
